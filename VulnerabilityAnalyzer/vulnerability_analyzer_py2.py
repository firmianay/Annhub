# -*- coding: utf-8 -*-
"""
因所使用 androguard 库为 py2，此文件也为 py2

对特定漏洞进行扫描，输出文件：vulnerability_report.txt
获取所有字符串用于后续研究，输出文件：strings.txt
"""

from __future__ import division
from modules.tools.androguard_py2.core.bytecodes import apk
from modules.tools.androguard_py2.core.bytecodes import dvm
from modules.tools.androguard_py2.core.analysis import analysis
import re
import base64
import collections
from textwrap import TextWrapper


# 漏洞等级
LEVEL_CRITICAL = "Critical"
LEVEL_WARNING = "Warning"
LEVEL_NOTICE = "Notice"
LEVEL_INFO = "Info"


class Writer:
    def __init__(self):
        self.__cache_output_detail_stream = []
        self.__output_dict_vector_result_information = {}  # Store the result information (key: tag ; value: information_for_each_vector)
        self.__output_current_tag = ""  # The current vector analyzed

        self.__file_io_result_output_list = []  # Analyze vector result (for more convenient to save in disk)

    def show_Path(self, vm, path):
        """
            Different from analysis.show_Path, this "show_Path" writes to the tmp writer 
        """

        cm = vm.get_class_manager()

        if isinstance(path, analysis.PathVar):
            dst_class_name, dst_method_name, dst_descriptor = path.get_dst(cm)
            info_var = path.get_var_info()

            self.write("=> %s (0x%x) ---> %s->%s%s" % (info_var,
                                                       path.get_idx(),
                                                       dst_class_name,
                                                       dst_method_name,
                                                       dst_descriptor))

        else:
            if path.get_access_flag() == analysis.TAINTED_PACKAGE_CALL:
                src_class_name, src_method_name, src_descriptor = path.get_src(cm)
                dst_class_name, dst_method_name, dst_descriptor = path.get_dst(cm)

                self.write("=> %s->%s%s (0x%x) ---> %s->%s%s" % (src_class_name,
                                                                 src_method_name,
                                                                 src_descriptor,
                                                                 path.get_idx(),
                                                                 dst_class_name,
                                                                 dst_method_name,
                                                                 dst_descriptor))

            else:
                src_class_name, src_method_name, src_descriptor = path.get_src(cm)

                self.write("=> %s->%s%s (0x%x)" % (src_class_name,
                                                   src_method_name,
                                                   src_descriptor,
                                                   path.get_idx()))


    def show_Paths(self, vm, paths):
        """
            Show paths of packages
            :param paths: a list of :class:`PathP` objects

            Different from "analysis.show_Paths", this "show_Paths" writes to the tmp writer 
        """
        for path in paths:
            self.show_Path(vm, path)

    def show_single_PathVariable(self, vm, path):
        """
            Different from "analysis.show_single_PathVariable", this "show_single_PathVariable" writes to the tmp writer 

            method[0] : class name
            method[1] : function name
            method[2][0] + method[2][1]) : description
        """
        access, idx = path[0]
        m_idx = path[1]
        method = vm.get_cm_method(m_idx)

        self.write("=> %s->%s %s" % (method[0], method[1], method[2][0] + method[2][1]))

    def startWriter(self, tag, level, summary, title_msg, special_tag=None, cve_number=""):
        """
            "tag" is for internal usage
            "level, summary, title_msg, special_tag, cve_number" will be shown to the users
            It will be sorted by the "tag". The result will be sorted by the "tag".

            Notice: the type of "special_tag" is "list"
        """
        self.completeWriter()
        self.__output_current_tag = tag

        assert ((tag is not None) and (level is not None) and (summary is not None) and (
        title_msg is not None)), "\"tag\", \"level\", \"summary\", \"title_msg\" should all have it's value."

        if tag not in self.__output_dict_vector_result_information:
            self.__output_dict_vector_result_information[tag] = []

        dict_tmp_information = dict()
        dict_tmp_information["level"] = level
        dict_tmp_information["title"] = title_msg.rstrip('\n')
        dict_tmp_information["summary"] = summary.rstrip('\n')
        dict_tmp_information["count"] = 0
        if special_tag:
            assert isinstance(special_tag, list), "Tag [" + tag + "] : special_tag should be list"
            dict_tmp_information["special_tag"] = special_tag
        if cve_number:
            assert isinstance(cve_number, basestring), "Tag [" + tag + "] : special_tag should be string"
            dict_tmp_information["cve_number"] = cve_number

        self.__output_dict_vector_result_information[tag] = dict_tmp_information

    def write(self, detail_msg):
        self.__cache_output_detail_stream.append(detail_msg + "\n")

    def completeWriter(self):
        # save to DB
        if (self.__cache_output_detail_stream) and (self.__output_current_tag != ""):
            # This is the preferred way if you know that your variable is a string. If your variable could also be some other type then you should use myString == ""

            current_tag = self.__output_current_tag
            # try :
            if current_tag in self.__output_dict_vector_result_information:
                self.__output_dict_vector_result_information[current_tag]["count"] = len(self.__cache_output_detail_stream)

                output_string = ""
                for line in self.__cache_output_detail_stream:
                    output_string = output_string + str(line)

                self.__output_dict_vector_result_information[current_tag]["vector_details"] = (output_string.rstrip(str('\n')))
                try:
                    self.__output_dict_vector_result_information[current_tag]["title"] = (self.__output_dict_vector_result_information[current_tag]["title"])
                except KeyError:
                    print("[KeyError on \"self.__output_dict_vector_result_information\"]")

        self.__output_current_tag = ""
        self.__cache_output_detail_stream[:] = []  # Clear the items in the list

    def is_dict_information_has_cve_number(self, dict_information):
        if dict_information:
            if "cve_number" in dict_information:
                return True
        return False

    def is_dict_information_has_special_tag(self, dict_information):
        if dict_information:
            if "special_tag" in dict_information:
                if dict_information["special_tag"]:
                    return True
        return False

    def __sort_by_level(key, value):
        try:
            level = value[1]["level"]

            if level == LEVEL_CRITICAL:
                return 5
            elif level == LEVEL_WARNING:
                return 4
            elif level == LEVEL_NOTICE:
                return 3
            elif level == LEVEL_INFO:
                return 2
            else:
                return 1
        except KeyError:
            return 1

    def save_result_to_file(self, path_to_vul_report):
        if not self.__file_io_result_output_list:
            self.load_to_output_list()

        try:
            with open(path_to_vul_report, "w") as f:
                for line in self.__file_io_result_output_list:
                    f.write(line + "\n")

            return True
        except:
            return False

    def output(self, line):  # Store here for later use on "print()" or "with ... open ..."
        self.__file_io_result_output_list.append(line)

    def load_to_output_list(self):
        """
            tag => dict(level, title_msg, special_tag, cve_number)
            tag => list(detail output)

            print(self.__output_dict_vector_result_information)
            print(self.__output_dict_vector_result_information["vector_details"])

            "vector_details" is a detail string of a vector separated by "\n" controlled by the users
        """

        self.__file_io_result_output_list[:] = []

        wrapperTitle = TextWrapper(initial_indent=' ' * 11, subsequent_indent=' ' * 11, width=140)
        wrapperDetail = TextWrapper(initial_indent=' ' * 15, subsequent_indent=' ' * 20, width=140)

        sorted_output_dict_result_information = collections.OrderedDict(sorted(self.__output_dict_vector_result_information.items()))

        for tag, dict_information in sorted(sorted_output_dict_result_information.items(), key=self.__sort_by_level, reverse=True):
            extra_field = ""
            if self.is_dict_information_has_special_tag(dict_information):
                for i in dict_information["special_tag"]:
                    extra_field += ("<" + i + ">")
            if self.is_dict_information_has_cve_number(dict_information):
                extra_field += ("<#" + dict_information["cve_number"] + "#>")

            self.output("[%s] %s %s:" % (dict_information["level"], extra_field, dict_information["summary"]))

            for line in dict_information["title"].split('\n'):
                self.output(wrapperTitle.fill(line))

            if "vector_details" in dict_information:
                for line in dict_information["vector_details"].split('\n'):
                    self.output(wrapperDetail.fill(line))


class EfficientStringSearchEngine:
    """
        Usage:
            1.create an EfficientStringSearchEngine instance (only one should be enough)
            2.addSearchItem
            3.search
            4.get_search_result_by_match_id or get_search_result_dict_key_classname_value_methodlist_by_match_id
    """

    def __init__(self):
        self.__prog_list = []
        self.__dict_result_identifier_to_search_result_list = {}

    def addSearchItem(self, match_id, search_regex_or_fix_string_condition, isRegex):
        self.__prog_list.append((match_id, search_regex_or_fix_string_condition, isRegex))  # "root" checking

    def search(self, vm, allstrings_list):

        """
            Example prog list input:
                [ ("match1", re.compile("PRAGMA\s*key\s*=", re.I), True), ("match2", re.compile("/system/bin/"), True), ("match3", "/system/bin/", False) ]

            Example return (Will always return the corresponding key, but the value is return only when getting the result):
                { "match1": [ (Complete_String_found, EncoddedMethod), (Complete_String_found, EncoddedMethod) ] , "match2": [] }
        """

        self.__dict_result_identifier_to_search_result_list.clear()

        for identifier, _, _ in self.__prog_list:  # 初始化返回列表
            if identifier not in self.__dict_result_identifier_to_search_result_list:
                self.__dict_result_identifier_to_search_result_list[identifier] = []

        dict_string_value_to_idx_from_file_mapping = {}

        for idx_from_file, string_value in vm.get_all_offset_from_file_and_string_value_mapping():  # get a dictionary of string value and string idx mapping
            dict_string_value_to_idx_from_file_mapping[string_value] = idx_from_file

        list_strings_idx_to_find = []  # string idx list
        dict_string_idx_to_identifier = {}  # Example: (52368, "match1")

        # Get the searched strings into search idxs
        for line in allstrings_list:
            for identifier, regexp, isRegex in self.__prog_list:
                if (isRegex and regexp.search(line)) or ((not isRegex) and (regexp == line)):
                    if line in dict_string_value_to_idx_from_file_mapping:  # Find idx by string
                        string_idx = dict_string_value_to_idx_from_file_mapping[line]
                        list_strings_idx_to_find.append(string_idx)
                        dict_string_idx_to_identifier[string_idx] = identifier

        list_strings_idx_to_find = set(list_strings_idx_to_find)  # strip duplicated items

        if list_strings_idx_to_find:
            cm = vm.get_class_manager()
            for method in vm.get_methods():
                for i in method.get_instructions():  # method.get_instructions(): Instruction
                    if (i.get_op_value() == 0x1A) or (
                        i.get_op_value() == 0x1B):  # 0x1A = "const-string", 0x1B = "const-string/jumbo"
                        ref_kind_idx = cm.get_offset_idx_by_from_file_top_idx(i.get_ref_kind())
                        if ref_kind_idx in list_strings_idx_to_find:  # find string_idx in string_idx_list
                            if ref_kind_idx in dict_string_idx_to_identifier:
                                original_identifier_name = dict_string_idx_to_identifier[ref_kind_idx]
                                self.__dict_result_identifier_to_search_result_list[original_identifier_name].append(
                                    (i.get_string(), method))

        return self.__dict_result_identifier_to_search_result_list

    def get_search_result_by_match_id(self, match_id):
        return self.__dict_result_identifier_to_search_result_list[match_id]

    def get_search_result_dict_key_classname_value_methodlist_by_match_id(self, match_id):
        """
            Input: [ (Complete_String_found, EncoddedMethod), (Complete_String_found, EncoddedMethod) ] or []
            Output: dicionary key by class name
        """
        dict_result = {}

        search_result_value = self.__dict_result_identifier_to_search_result_list[match_id]

        try:
            if search_result_value:  # Found the corresponding url in the code
                result_list = set(search_result_value)

                for _, result_method in result_list:  # strip duplicated item
                    class_name = result_method.get_class_name()
                    if class_name not in dict_result:
                        dict_result[class_name] = []

                    dict_result[class_name].append(result_method)
        except KeyError:
            pass

        return dict_result


class FilteringEngine:
    def __init__(self):
        self.__regexp_excluded_classes = re.compile("^(Landroid/support/|Lcom/actionbarsherlock/|Lorg/apache/)", re.I)

    def get_filtering_regexp(self):
        return self.__regexp_excluded_classes

    def filter_efficient_search_result_value(self, result):
        if result is None:
            return []

        l = []
        for found_string, method in result:
            if not self.__regexp_excluded_classes.match(method.get_class_name()):
                l.append((found_string, method))

        return l

    def is_class_name_not_in_exclusion(self, class_name):
        if self.__regexp_excluded_classes.match(class_name):
            return False
        else:
            return True

    def is_all_of_key_class_in_dict_not_in_exclusion(self, dict_result):
        isAllMatchExclusion = True
        for class_name, method_list in dict_result.items():
            if not self.__regexp_excluded_classes.match(class_name):
                isAllMatchExclusion = False

        if isAllMatchExclusion:
            return False

        return True

    def filter_list_of_methods(self, method_list):
        if method_list:
            l = []
            for method in method_list:
                if not self.__regexp_excluded_classes.match(method.get_class_name()):
                    l.append(method)
            return l
        else:
            return method_list

    def filter_list_of_classes(self, class_list):
        if class_list:
            l = []
            for i in class_list:
                if not self.__regexp_excluded_classes.match(i):
                    l.append(i)
            return l
        else:
            return class_list

    def filter_list_of_paths(self, vm, paths):
        if paths:
            cm = vm.get_class_manager()

            l = []
            for path in paths:
                src_class_name, src_method_name, src_descriptor = path.get_src(cm)
                if not self.__regexp_excluded_classes.match(src_class_name):
                    l.append(path)

            return l
        else:
            return paths

    def filter_list_of_variables(self, vm, paths):
        """
            Example paths input: [[('R', 8), 5050], [('R', 24), 5046]]
        """

        if paths:
            l = []
            for path in paths:
                access, idx = path[0]
                m_idx = path[1]
                method = vm.get_cm_method(m_idx)
                class_name = method[0]

                if not self.__regexp_excluded_classes.match(class_name):
                    l.append(path)
            return l
        else:
            return paths

    def get_class_container_dict_by_new_instance_classname_in_paths(self, vm, analysis, paths, result_idx):  # dic: key=>class_name, value=>paths
        dic_classname_to_paths = {}
        paths = self.filter_list_of_paths(vm, paths)
        for i in analysis.trace_Register_value_by_Param_in_source_Paths(vm, paths):
            if (i.getResult()[result_idx] is None) or (
            not i.is_class_container(result_idx)):  # If parameter 0 is a class_container type (ex: Lclass/name;)
                continue
            class_container = i.getResult()[result_idx]
            class_name = class_container.get_class_name()
            if class_name not in dic_classname_to_paths:
                dic_classname_to_paths[class_name] = []
            dic_classname_to_paths[class_name].append(i.getPath())
        return dic_classname_to_paths


def isNullOrEmptyString(input_string, strip_whitespaces=False):
    if input_string is None:
        return True
    if strip_whitespaces:
        if input_string.strip() == "":
            return True
    else:
        if input_string == "":
            return True
    return False


def is_class_implements_interface(cls, search_interfaces):
    class_interfaces = cls.get_interfaces()
    if class_interfaces is None:
        return False

    for i in search_interfaces:
        if i in class_interfaces:
            return True
    return False


def get_method_ins_by_superclass_and_method(vm, super_classes, method_name, method_descriptor):
    for cls in vm.get_classes():
        if cls.get_superclassname() in super_classes:
            for method in cls.get_methods():
                if (method.get_name() == method_name) and (method.get_descriptor() == method_descriptor):
                    yield method


def get_method_ins_by_implement_interface_and_method(vm, implement_interface, method_name, method_descriptor):
    """
        Example result:
            (Ljavax/net/ssl/HostnameVerifier; Ljava/io/Serializable;)
    """

    for cls in vm.get_classes():
        if is_class_implements_interface(cls, implement_interface):
            for method in cls.get_methods():
                if (method.get_name() == method_name) and (method.get_descriptor() == method_descriptor):
                    yield method


def get_method_ins_by_implement_interface_and_method_desc_dict(vm, implement_interface, method_name_and_descriptor_list):
    dict_result = {}

    for cls in vm.get_classes():
        if is_class_implements_interface(cls, implement_interface):
            class_name = cls.get_name()
            if class_name not in dict_result:
                dict_result[class_name] = []

            for method in cls.get_methods():
                name_and_desc = method.get_name() + method.get_descriptor()
                if name_and_desc in method_name_and_descriptor_list:
                    dict_result[class_name].append(method)

    return dict_result


def is_kind_string_in_ins_method(method, kind_string):
    for ins in method.get_instructions():
        try:
            if ins.get_kind_string() == kind_string:
                return True
        except AttributeError:  # Because the instruction may not have "get_kind_string()" method
            return False
    return False


def get_all_components_by_permission(xml, permission):
    """
    获取有特权的四大组件
    """
    find_tags = ["activity", "activity-alias", "service", "receiver", "provider"]
    dict_perms = {}

    for tag in find_tags:
        for item in xml.getElementsByTagName(tag):
            if (item.getAttribute("android:permission") == permission) or (
                item.getAttribute("android:readPermission") == permission) or (
                item.getAttribute("android:writePermission") == permission):
                if tag not in dict_perms:
                    dict_perms[tag] = []
                dict_perms[tag].append(item.getAttribute("android:name"))
    return dict_perms


def do_analyze(writer, app_home, path_to_app):
    """
    漏洞分析主函数
    """

    efficientStringSearchEngine = EfficientStringSearchEngine()
    filteringEngine = FilteringEngine()

    isUsingSQLCipher = False
    isMasterKeyVulnerability = False

    a = apk.APK(path_to_app)

    # 获取 min_sdk 和 target_sdk
    try:
        min_sdk = a.get_min_sdk_version()
        if (min_sdk is None) or (min_sdk == ""):
            raise ValueError
        else:
            int_min_sdk = int(min_sdk)
    except ValueError:
        int_min_sdk = 1

    try:
        target_sdk = a.get_target_sdk_version()
        if (target_sdk is None) or (target_sdk == ""):
            raise ValueError
        else:
            int_target_sdk = int(target_sdk)
    except ValueError:
        int_target_sdk = int_min_sdk


    d = dvm.DalvikVMFormat(a.get_dex())

    vmx = analysis.VMAnalysis(d)

    all_permissions = a.get_permissions()

    # 获取所有字符串并保存到文件 string.txt
    allstrings = d.get_strings()
    with open(app_home+'/strings.txt', 'w') as f:
        for line in allstrings:
            f.write(line)


    # ------------------------------------------------------------------------
    efficientStringSearchEngine.addSearchItem("$__possibly_check_root__", re.compile("/system/bin"), True)  # 检查是否root_1
    efficientStringSearchEngine.addSearchItem("$__possibly_check_su__", "su", False)  # 检查是否root_2
    efficientStringSearchEngine.addSearchItem("$__sqlite_encryption__", re.compile("PRAGMA\s*key\s*=", re.I), True)  # SQLite加密检查

    # ------------------------------------------------------------------------
    # 打印出所有未使用SSL加密的网址
    exception_url_string = ["http://example.com",
                            "http://example.com/",
                            "http://www.example.com",
                            "http://www.example.com/",
                            "http://www.google-analytics.com/collect",
                            "http://www.google-analytics.com",
                            "http://hostname/?",
                            "http://hostname/"]

    allurls_strip_duplicated = []
    for line in allstrings:
        if re.match('http\:\/\/(.+)', line):
            allurls_strip_duplicated.append(line)

    allurls_strip_non_duplicated = sorted(set(allurls_strip_duplicated))
    allurls_strip_non_duplicated_final = []

    if allurls_strip_non_duplicated:
        for url in allurls_strip_non_duplicated:
            if (url not in exception_url_string) and (not url.startswith("http://schemas.android.com/")) and \
                    (not url.startswith("http://www.w3.org/")) and \
                    (not url.startswith("http://apache.org/")) and \
                    (not url.startswith("http://xml.org/")) and \
                    (not url.startswith("http://localhost/")) and \
                    (not url.startswith("http://java.sun.com/")) and \
                    (not url.endswith("/namespace")) and \
                    (not url.endswith("-dtd")) and \
                    (not url.endswith(".dtd")) and \
                    (not url.endswith("-handler")) and \
                    (not url.endswith("-instance")):

                efficientStringSearchEngine.addSearchItem(url, url, False)

                allurls_strip_non_duplicated_final.append(url)

    # ------------------------------------------------------------------------
    # Base64 字符串解码
    list_base64_success_decoded_string_to_original_mapping = {}
    list_base64_excluded_original_string = ["endsWith", "allCells", "fillList", "endNanos", "cityList", "cloudid=", "Liouciou"]

    for line in allstrings:
        is_base64 = re.match('^[A-Za-z0-9+/]+[=]{0,2}$', line)
        if (is_base64) and (len(line) >= 3):
            try:
                decoded_string = base64.b64decode(line)
                isSuccessBase64DecodedString = re.match('^[A-Za-z0-9\\\:\;\/\-\.\,\?\=\<\>\+\_\(\)\[\]\{\}\|\"\'\~\`\*]+$', decoded_string)
                if isSuccessBase64DecodedString:
                    if len(decoded_string) > 3:
                        if (decoded_string not in list_base64_success_decoded_string_to_original_mapping) and (
                            line not in list_base64_excluded_original_string):
                            list_base64_success_decoded_string_to_original_mapping[decoded_string] = line
                            efficientStringSearchEngine.addSearchItem(line, line, False)
            except:
                pass

    # ------------------------------------------------------------------------
    # 开启搜索核心引擎
    efficientStringSearchEngine.search(d, allstrings)

    # ------------------------------------------------------------------------
    # 在输出url结果时提前检查预先检查以避免错误
    allurls_strip_non_duplicated_final_prerun_count = 0
    for url in allurls_strip_non_duplicated_final:
        dict_class_to_method_mapping = efficientStringSearchEngine.get_search_result_dict_key_classname_value_methodlist_by_match_id(url)
        if filteringEngine.is_all_of_key_class_in_dict_not_in_exclusion(dict_class_to_method_mapping):
            allurls_strip_non_duplicated_final_prerun_count = allurls_strip_non_duplicated_final_prerun_count + 1

    if allurls_strip_non_duplicated_final_prerun_count != 0:
        writer.startWriter("SSL_URLS_NOT_IN_HTTPS", LEVEL_CRITICAL, "SSL连接检查",
                           "没有使用 SSL 的网址(总共:" + str(allurls_strip_non_duplicated_final_prerun_count) + "个):", ["SSL_Security"])

        for url in allurls_strip_non_duplicated_final:

            dict_class_to_method_mapping = efficientStringSearchEngine.get_search_result_dict_key_classname_value_methodlist_by_match_id(
                url)
            if not filteringEngine.is_all_of_key_class_in_dict_not_in_exclusion(dict_class_to_method_mapping):
                continue

            writer.write(url)

            try:
                if dict_class_to_method_mapping:  # Found the corresponding url in the code
                    for _, result_method_list in dict_class_to_method_mapping.items():
                        for result_method in result_method_list:  # strip duplicated item
                            if filteringEngine.is_class_name_not_in_exclusion(result_method.get_class_name()):
                                source_classes_and_functions = (
                                result_method.get_class_name() + "->" + result_method.get_name() + result_method.get_descriptor())
                                writer.write("    => " + source_classes_and_functions)

            except KeyError:
                pass

    else:
        writer.startWriter("SSL_URLS_NOT_IN_HTTPS", LEVEL_INFO, "SSL连接检查",
                           "没有发现没有使用 SSL 的网址（注意：如果您加密了 url 字符串，则无法发现）。",
                           ["SSL_Security"])

    # --------------------------------------------------------------------

    regexGerneralRestricted = ".*(config|setting|constant).*";
    regexSecurityRestricted = ".*(encrypt|decrypt|encod|decod|aes).*"  # No need to add and "des"
    # show the user which package is excluded

    prog = re.compile(regexGerneralRestricted, re.I)
    prog_sec = re.compile(regexSecurityRestricted, re.I)

    # Security methods finding:

    dexes_count = 0
    all_files = a.get_files()
    for f in all_files:
        if f == 'classes.dex':
            dexes_count += 1

    if dexes_count > 1:
        isMasterKeyVulnerability = True

    if isMasterKeyVulnerability:
        writer.startWriter("MASTER_KEY", LEVEL_CRITICAL, "主密钥类型I漏洞",
                           "此APK受到主密钥类型I漏洞的攻击。", None, "CVE-2013-4787")
    else:
        writer.startWriter("MASTER_KEY", LEVEL_INFO, "主密钥类型I漏洞",
                           "此APK不受主密钥类型I漏洞的攻击。", None, "CVE-2013-4787")


    # DEBUGGABLE checking:

    is_debug_open = a.is_debuggable()
    if is_debug_open:
        writer.startWriter("DEBUGGABLE", LEVEL_CRITICAL, "Android调试模式检查",
                           "AndroidManifest.xml 中调试模式被打开(android:debuggable=\"true\")。这是非常危险的。攻击者将能够通过 Logcat 来嗅探调试消息。如果是发布的应用程序，请禁用DEBUG模式。",
                           ["Debug"])

    else:
        writer.startWriter("DEBUGGABLE", LEVEL_INFO, "Android调试模式检查",
                           "AndroidManifest.xml 中调试模式已关闭(android:debuggable=\"false\")。", ["Debug"])

    # ------------------------------------------------------------------------------------------------------

    # Checking whether the app is checking debuggable:

    """
        Java code checking debuggable:
            boolean isDebuggable = (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE));
            if (isDebuggable) { }

        Smali code checking debuggable:
            invoke-virtual {p0}, Lcom/example/androiddebuggable/MainActivity;->getApplicationInfo()Landroid/content/pm/ApplicationInfo;
            move-result-object v1
            iget v1, v1, Landroid/content/pm/ApplicationInfo;->flags:I
            and-int/lit8 v1, v1, 0x2
            if-eqz v1, :cond_0

        Checking Pattern:
            1. Find tainted calling field: Landroid/content/pm/ApplicationInfo;->flags:I
            2. Get the next instruction of the calling field: Landroid/content/pm/ApplicationInfo;->flags:I
            3. Check whether the next instruction is 0xDD(and-int/lit8) and make sure the register numbers are all matched
                iget [[v1]], v1, [[[Landroid/content/pm/ApplicationInfo;->flags:I]]]
                and-int/lit8 v1, [[v1]], [0x2]

    """
    list_detected_FLAG_DEBUGGABLE_path = []
    field_ApplicationInfo_flags_debuggable = vmx.get_tainted_field("Landroid/content/pm/ApplicationInfo;", "flags", "I")

    if field_ApplicationInfo_flags_debuggable:
        for path, stack in field_ApplicationInfo_flags_debuggable.get_paths_and_stacks(d, filteringEngine.get_filtering_regexp()):
            last_one_ins = stack.gets()[-1]
            last_two_ins = stack.gets()[-2]

            if (last_one_ins is not None) and (last_two_ins is not None):
                try:
                    if (last_one_ins[0] == 0xDD) and (last_two_ins[1][0][1] == last_one_ins[1][1][1]) and (
                        last_one_ins[1][2][1] == 2):  # and-int/lit8 vx,vy,lit8
                        list_detected_FLAG_DEBUGGABLE_path.append(path)
                    """
                        Example 1:
                            last_two_ins => [82, [(0, 1), (0, 1), (258, 16, 'Landroid/content/pm/ApplicationInfo;->flags I')]]
                            last_one_ins => [221, [(0, 1), (0, 1), (1, 2)]]

                        Example 2:
                            last_two_ins => [82, [(0, 2), (0, 0), (258, 896, 'Landroid/content/pm/ApplicationInfo;->flags I')]]
                            last_one_ins => [221, [(0, 2), (0, 2), (1, 2)]]

                        Java code:
                            stack.show()
                            print(last_one_ins)
                            print(last_two_ins)
                    """
                except:
                    pass

    if list_detected_FLAG_DEBUGGABLE_path:
        writer.startWriter("HACKER_DEBUGGABLE_CHECK", LEVEL_NOTICE, "检查Android调试模式的代码",
                           "找到用于在 AndroidManifest.xml 中检查 \"ApplicationInfo.FLAG_DEBUGGABLE\" 的代码：",
                           ["Debug", "Hacker"])

        for path in list_detected_FLAG_DEBUGGABLE_path:
            writer.show_single_PathVariable(d, path)
    else:
        writer.startWriter("HACKER_DEBUGGABLE_CHECK", LEVEL_INFO, "检查Android调试模式的代码",
                           "没有找到用于在 AndroidManifest.xml 中检查 \"ApplicationInfo.FLAG_DEBUGGABLE\" 的代码。",
                           ["Debug", "Hacker"])

    # ----------------------------------------------------------------------------------

    ACCESS_MOCK_LOCATION = "android.permission.ACCESS_MOCK_LOCATION"
    if ACCESS_MOCK_LOCATION in all_permissions:
        writer.startWriter("USE_PERMISSION_ACCESS_MOCK_LOCATION", LEVEL_CRITICAL, "检查不必要的权限",
                           "权限 'android.permission.ACCESS_MOCK_LOCATION' 仅适用于模拟器环境。如果是发布的应用程序，请删除此权限。")
    else:
        writer.startWriter("USE_PERMISSION_ACCESS_MOCK_LOCATION", LEVEL_INFO, "检查不必要的权限",
                           "权限 'android.permission.ACCESS_MOCK_LOCATION' 设置正确。")

    # ----------------------------------------------------------------------------------

    permissionNameOfWrongPermissionGroup = a.get_permission_tag_wrong_settings_names()

    if permissionNameOfWrongPermissionGroup:  # If the list is not empty
        writer.startWriter("PERMISSION_GROUP_EMPTY_VALUE", LEVEL_CRITICAL, "AndroidManifest 权限组检查",
                           "将 “PermissionGroup” 属性设置为空值将使权限定义变得无效，并且没有其他应用程序能够使用该权限。")

        for name in permissionNameOfWrongPermissionGroup:
            writer.write("Permission name '%s' sets an empty value in `permissionGroup` attribute." % (name))
    else:
        writer.startWriter("PERMISSION_GROUP_EMPTY_VALUE", LEVEL_INFO, "AndroidManifest 权限组检查",
                           "AndroidManifest 权限标签中的 ”PermissionGroups“ 设置正确。")

    # ----------------------------------------------------------------------------------

    # Critical use-permission check:
    user_permission_critical_manufacturer = ["android.permission.INSTALL_PACKAGES",
                                             "android.permission.WRITE_SECURE_SETTINGS"]
    user_permission_critical = ["android.permission.MOUNT_FORMAT_FILESYSTEMS",
                                "android.permission.MOUNT_UNMOUNT_FILESYSTEMS", "android.permission.RESTART_PACKAGES"]

    list_user_permission_critical_manufacturer = []
    list_user_permission_critical = []

    for permission in all_permissions:
        if permission in user_permission_critical_manufacturer:
            list_user_permission_critical_manufacturer.append(permission)
        if permission in user_permission_critical:
            list_user_permission_critical.append(permission)

    if list_user_permission_critical_manufacturer or list_user_permission_critical:
        if list_user_permission_critical_manufacturer:
            writer.startWriter("USE_PERMISSION_SYSTEM_APP", LEVEL_CRITICAL,
                               "检查 AndroidManifest 系统使用权限",
                               "该应用程序只能由设备制造商或Google发布并签署，并放在 “/system/app” 下。如果没有，可能是恶意应用程序。")

            for permission in list_user_permission_critical_manufacturer:
                writer.write("System use-permission found: \"" + permission + "\"")

        if list_user_permission_critical:
            writer.startWriter("USE_PERMISSION_CRITICAL", LEVEL_CRITICAL, "检查 AndroidManifest 系统使用权限",
                               "此 app 有很高的特权，请小心使用。")

            for permission in list_user_permission_critical:
                writer.write("Critical use-permission found: \"" + permission + "\"")
    else:
        writer.startWriter("USE_PERMISSION_SYSTEM_APP", LEVEL_INFO, "检查 AndroidManifest 系统使用权限", "没有找到关键系统使用权限。")

    # ----------------------------------------------------------------------------------

    isSuggestGCM = False
    if int_min_sdk is not None:
        if int_min_sdk < 8:
            isSuggestGCM = True

    if isSuggestGCM:

        output_string = """你所支持的 min sdk 为 """ + str(int_min_sdk) + """
你现在允许的 min sdk 小于 8。 请查看: http://developer.android.com/about/dashboards/index.html
Google Cloud Messaging 服务仅允许 Android SDK >= 8 (Android 2.2)。 请查看: http://developer.android.com/google/gcm/gcm.html
您未来可能需要使用 GCM 来代替，请设置 min sdk 至少为 9。"""
        writer.startWriter("MANIFEST_GCM", LEVEL_NOTICE, "检查 Google Cloud Messaging", output_string)

    else:

        writer.startWriter("MANIFEST_GCM", LEVEL_INFO, "检查 Google Cloud Messaging", "无")

    # ------------------------------------------------------------------------------------------------------
    # Find network methods:

    # pkg_xxx is a 'PathP' object
    pkg_URLConnection = vmx.get_tainted_packages().search_packages("Ljava/net/URLConnection;")
    pkg_HttpURLConnection = vmx.get_tainted_packages().search_packages("Ljava/net/HttpURLConnection;")
    pkg_HttpsURLConnection = vmx.get_tainted_packages().search_packages("Ljavax/net/ssl/HttpsURLConnection;")
    pkg_DefaultHttpClient = vmx.get_tainted_packages().search_packages(
        "Lorg/apache/http/impl/client/DefaultHttpClient;")
    pkg_HttpClient = vmx.get_tainted_packages().search_packages("Lorg/apache/http/client/HttpClient;")

    pkg_URLConnection = filteringEngine.filter_list_of_paths(d, pkg_URLConnection)
    pkg_HttpURLConnection = filteringEngine.filter_list_of_paths(d, pkg_HttpURLConnection)
    pkg_HttpsURLConnection = filteringEngine.filter_list_of_paths(d, pkg_HttpsURLConnection)
    pkg_DefaultHttpClient = filteringEngine.filter_list_of_paths(d, pkg_DefaultHttpClient)
    pkg_HttpClient = filteringEngine.filter_list_of_paths(d, pkg_HttpClient)



    if pkg_URLConnection or pkg_HttpURLConnection or pkg_HttpsURLConnection or pkg_DefaultHttpClient or pkg_HttpClient:

        if "android.permission.INTERNET" in all_permissions:
            writer.startWriter("USE_PERMISSION_INTERNET", LEVEL_INFO, "检查互联网访问",
                               "这个应用程序是通过 HTTP 协议使用 Internet。")

        else:
            writer.startWriter("USE_PERMISSION_INTERNET", LEVEL_CRITICAL, "检查互联网访问",
                               "此应用程序有一些互联网访问代码，但 AndroidManifest 中没有 “android.permission.INTERNET” 使用权限。")

    else:
        writer.startWriter("USE_PERMISSION_INTERNET", LEVEL_INFO, "检查互联网访问",
                           "未找到与HTTP相关的连接代码。")

    # ------------------------------------------------------------------------

    # Base64 String decoding:

    organized_list_base64_success_decoded_string_to_original_mapping = []
    for decoded_string, original_string in list_base64_success_decoded_string_to_original_mapping.items():
        dict_class_to_method_mapping = efficientStringSearchEngine.get_search_result_dict_key_classname_value_methodlist_by_match_id(
            original_string)
        if filteringEngine.is_all_of_key_class_in_dict_not_in_exclusion(dict_class_to_method_mapping):
            """
                All of same string found are inside the excluded packages.
                Only the strings found the original class will be added.
            """
            organized_list_base64_success_decoded_string_to_original_mapping.append(
                (decoded_string, original_string, dict_class_to_method_mapping))

    if organized_list_base64_success_decoded_string_to_original_mapping:  # The result is from the upper code section

        list_base64_decoded_urls = {}

        writer.startWriter("HACKER_BASE64_STRING_DECODE", LEVEL_CRITICAL, "Base64字符串加密",
                           "找到 Base64 加密的字符串 (总共: " + str(len(
                               organized_list_base64_success_decoded_string_to_original_mapping)) + "个)。不能保证所有的字符串都是Base64编码，也不会向您显示解码的二进制文件：",
                           ["Hacker"])

        for decoded_string, original_string, dict_class_to_method_mapping in organized_list_base64_success_decoded_string_to_original_mapping:

            writer.write(decoded_string)
            writer.write("    ->Original Encoding String: " + original_string)

            if dict_class_to_method_mapping:
                for class_name, result_method_list in dict_class_to_method_mapping.items():
                    for result_method in result_method_list:
                        source_classes_and_functions = (
                        result_method.get_class_name() + "->" + result_method.get_name() + result_method.get_descriptor())
                        writer.write("    ->From class: " + source_classes_and_functions)

            if "http://" in decoded_string:
                list_base64_decoded_urls[decoded_string] = original_string

        if list_base64_decoded_urls:

            writer.startWriter("HACKER_BASE64_URL_DECODE", LEVEL_CRITICAL, "Base64字符串加密",
                               "Base64编码字符串中没有使用 SSL 的 HTTP URL (总共: " + str(len(list_base64_decoded_urls)) + "个)。", ["SSL_Security", "Hacker"])

            for decoded_string, original_string in list_base64_decoded_urls.items():

                dict_class_to_method_mapping = efficientStringSearchEngine.get_search_result_dict_key_classname_value_methodlist_by_match_id(
                    original_string)

                if not filteringEngine.is_all_of_key_class_in_dict_not_in_exclusion(
                        dict_class_to_method_mapping):
                    continue

                writer.write(decoded_string)
                writer.write("    ->Original Encoding String: " + original_string)

                if dict_class_to_method_mapping:
                    for class_name, result_method_list in dict_class_to_method_mapping.items():
                        for result_method in result_method_list:
                            source_classes_and_functions = (
                            result_method.get_class_name() + "->" + result_method.get_name() + result_method.get_descriptor())
                            writer.write("    ->From class: " + source_classes_and_functions)

    else:
        writer.startWriter("HACKER_BASE64_STRING_DECODE", LEVEL_INFO, "Base64字符串加密", "没有找到编码的 Base64 字符串或 URL。", ["Hacker"])

    # ------------------------------------------------------------------------
    # WebView addJavascriptInterface checking:

    # Don't match class name because it might use the subclass of WebView
    path_WebView_addJavascriptInterface = vmx.get_tainted_packages().search_methods_exact_match(
        "addJavascriptInterface", "(Ljava/lang/Object; Ljava/lang/String;)V")
    path_WebView_addJavascriptInterface = filteringEngine.filter_list_of_paths(d, path_WebView_addJavascriptInterface)

    if path_WebView_addJavascriptInterface:

        output_string = """发现关键的WebView“addJavascriptInterface”漏洞。 该方法可用于允许 JavaScript 控制主机应用程序。
这是一个强大的功能，但也为面向 API 级别 JELLY_BEAN（4.2） 或更低版本的应用程序提供安全风险，因为 JavaScript 可以使用反射来访问注入对象的公共字段。
在包含不受信任内容的 WebView 中使用此方法可能允许攻击者以非预期的方式操纵主机应用程序，并使用主机应用程序的权限执行 Java 代码。
参考:
  1."http://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object, java.lang.String) "
  2.https://labs.mwrinfosecurity.com/blog/2013/09/24/webview-addjavascriptinterface-remote-code-execution/
  3.http://50.56.33.56/blog/?p=314
  4.http://blog.trustlook.com/2013/09/04/alert-android-webview-addjavascriptinterface-code-execution-vulnerability/
请检查下面的代码:"""

        writer.startWriter("WEBVIEW_RCE", LEVEL_CRITICAL, "WebView RCE 漏洞检查", output_string,
                           ["WebView", "Remote Code Execution"], "CVE-2013-4710")
        writer.show_Paths(d, path_WebView_addJavascriptInterface)

    else:

        writer.startWriter("WEBVIEW_RCE", LEVEL_INFO, "WebView RCE 漏洞检查", "没有找到 WebView addJavascriptInterface 漏洞。",
                           ["WebView", "Remote Code Execution"], "CVE-2013-4710")

    # ------------------------------------------------------------------------
    # KeyStore null PWD checking:

    list_no_pwd_probably_ssl_pinning_keystore = []
    list_no_pwd_keystore = []
    list_protected_keystore = []

    path_KeyStore = vmx.get_tainted_packages().search_class_methods_exact_match("Ljava/security/KeyStore;", "load",
                                                                                "(Ljava/io/InputStream; [C)V")
    path_KeyStore = filteringEngine.filter_list_of_paths(d, path_KeyStore)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_KeyStore):
        if i.getResult()[2] == 0:  # null = 0 = Not using password
            if (i.is_class_container(1)):
                clz_invoked = i.getResult()[1]
                if clz_invoked.get_class_name() == "Ljava/io/ByteArrayInputStream;":
                    list_no_pwd_probably_ssl_pinning_keystore.append(i.getPath())
                else:
                    list_no_pwd_keystore.append(i.getPath())
            else:
                if i.getResult()[1] == 0:  # null = 0
                    list_no_pwd_probably_ssl_pinning_keystore.append(i.getPath())
                else:
                    list_no_pwd_keystore.append(i.getPath())
        else:
            list_protected_keystore.append(i.getPath())

    if (not list_no_pwd_keystore) and (not list_protected_keystore) and (not list_no_pwd_probably_ssl_pinning_keystore):

        writer.startWriter("HACKER_KEYSTORE_NO_PWD", LEVEL_INFO, "KeyStore 保护检查", "未使用 KeyStore 或受密码保护。", ["KeyStore", "Hacker"])

    else:
        if list_no_pwd_probably_ssl_pinning_keystore:

            writer.startWriter("HACKER_KEYSTORE_SSL_PINNING", LEVEL_CRITICAL, "KeyStore 保护检查",
                               "下面的 KeyStore 似乎使用“字节数组”或“硬编码的证书信息”的 SSL-pinning (总共: " + str(
                                   len(list_no_pwd_probably_ssl_pinning_keystore)) + "个)。 请检查:",
                               ["KeyStore", "Hacker"])

            for keystore in list_no_pwd_probably_ssl_pinning_keystore:
                writer.show_Path(d, keystore)

        if list_no_pwd_keystore:

            writer.startWriter("HACKER_KEYSTORE_NO_PWD", LEVEL_CRITICAL, "KeyStore 保护检查",
                               "下面的 KeyStores 似乎不受密码保护(总共: " + str(
                                   len(list_no_pwd_keystore)) + "个)。请检查:", ["KeyStore", "Hacker"])

            for keystore in list_no_pwd_keystore:
                writer.show_Path(d, keystore)

        if list_protected_keystore:

            writer.startWriter("HACKER_KEYSTORE_SSL_PINNING2", LEVEL_NOTICE, "KeyStore 保护信息",
                               "下面的 KeyStore 通过密码“受保护”，似乎使用了 SSL-pinning (总共: " + str(
                                   len( list_protected_keystore)) + "个)。可以使用 “Portecle” 工具管理 KeyStore 中的证书：",
                               ["KeyStore", "Hacker"])

            for keystore in list_protected_keystore:
                writer.show_Path(d, keystore)

    # ------------------------------------------------------------------------
    # Find all keystore

    list_keystore_file_name = []
    list_possible_keystore_file_name = []

    for name, _, _ in a.get_files_information():
        """
            1.Name includes cert (search under /res/raw)
            2.ends with .bks (search all)
        """
        if name.endswith(".bks") or name.endswith(".jks"):
            if (name.startswith("res/")) and (
            not name.startswith("res/raw/")):  # If any files found on "/res" dir, only get from "/res/raw"
                continue
            list_keystore_file_name.append(name)
        elif ("keystore" in name) or ("cert" in name):
            if (name.startswith("res/")) and (
            not name.startswith("res/raw/")):  # If any files found on "/res" dir, only get from "/res/raw
                continue
            list_possible_keystore_file_name.append(name)

    if list_keystore_file_name or list_possible_keystore_file_name:
        if list_keystore_file_name:
            writer.startWriter("HACKER_KEYSTORE_LOCATION1", LEVEL_NOTICE, "KeyStore 文件位置",
                               "BKS密钥库文件：", ["KeyStore", "Hacker"])
            for i in list_keystore_file_name:
                writer.write(i)

        if list_possible_keystore_file_name:
            writer.startWriter("HACKER_KEYSTORE_LOCATION2", LEVEL_NOTICE, "可能的 KeyStore 文件位置",
                               "BKS可能的密钥库文件：", ["KeyStore", "Hacker"])
            for i in list_possible_keystore_file_name:
                writer.write(i)
    else:
        writer.startWriter("HACKER_KEYSTORE_LOCATION1", LEVEL_INFO, "KeyStore 文件位置",
                           "没有找到任何可能的BKS密钥库或证书密钥库文件（注意：这并不意味着此应用程序不使用密钥库）：",
                           ["KeyStore", "Hacker"])

    # ------------------------------------------------------------------------
    # BKS KeyStore checking:

    """
        Example:
        const-string v11, "BKS"
        invoke-static {v11}, Ljava/security/KeyStore;->getInstance(Ljava/lang/String;)Ljava/security/KeyStore;
    """

    list_Non_BKS_keystore = []
    path_BKS_KeyStore = vmx.get_tainted_packages().search_class_methods_exact_match("Ljava/security/KeyStore;",
                                                                                    "getInstance",
                                                                                    "(Ljava/lang/String;)Ljava/security/KeyStore;")
    path_BKS_KeyStore = filteringEngine.filter_list_of_paths(d, path_BKS_KeyStore)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_BKS_KeyStore):
        if i.getResult()[0] is None:
            continue
        if (i.is_string(i.getResult()[0])) and ((i.getResult()[0]).upper() != "BKS"):
            list_Non_BKS_keystore.append(i.getPath())

    if list_Non_BKS_keystore:
        writer.startWriter("KEYSTORE_TYPE_CHECK", LEVEL_CRITICAL, "KeyStore 类型检查",
                           "Android只接受“BKS”类型的KeyStore。 请确认您正在使用“BKS”类型的KeyStore：", ["KeyStore"])
        for keystore in list_Non_BKS_keystore:
            writer.show_Path(d, keystore)
    else:
        writer.startWriter("KEYSTORE_TYPE_CHECK", LEVEL_INFO, "KeyStore 类型检查", "KeyStore'BKS'类型检查正确",
                           ["KeyStore"])

    # ------------------------------------------------------------------------
    # Android PackageInfo signatures checking:

    """
        Example:

            move-result-object v0
            iget-object v2, v0, Landroid/content/pm/PackageInfo;->signatures:[Landroid/content/pm/Signature;

            PackageManager pkgManager = context.getPackageManager();
            pkgManager.getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES).signatures[0].toByteArray();
    """

    list_PackageInfo_signatures = []
    path_PackageInfo_signatures = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Landroid/content/pm/PackageManager;", "getPackageInfo",
        "(Ljava/lang/String; I)Landroid/content/pm/PackageInfo;")
    path_PackageInfo_signatures = filteringEngine.filter_list_of_paths(d, path_PackageInfo_signatures)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_PackageInfo_signatures):
        if i.getResult()[2] is None:
            continue
        if i.getResult()[2] == 64:
            list_PackageInfo_signatures.append(i.getPath())

    if list_PackageInfo_signatures:
        writer.startWriter("HACKER_SIGNATURE_CHECK", LEVEL_NOTICE, "检查获取签名的代码",
                           "此应用程序在代码中检查包签名。 它可能用于检查应用程序是否被攻击者入侵。", ["Signature", "Hacker"])
        for signature in list_PackageInfo_signatures:
            writer.show_Path(d, signature)
    else:
        writer.startWriter("HACKER_SIGNATURE_CHECK", LEVEL_INFO, "检查获取签名的代码",
                           "没有检测到这个应用程序正在检查代码中的签名。", ["Signature", "Hacker"])

    # ------------------------------------------------------------------------
    # Developers preventing screenshot capturing checking:

    """
        Example:
            const/16 v1, 0x2000
            invoke-super {p0, p1}, Landroid/support/v7/app/AppCompatActivity;->onCreate(Landroid/os/Bundle;)V
            invoke-virtual {p0}, Lcom/example/preventscreencapture/MainActivity;->getWindow()Landroid/view/Window;
            move-result-object v0
            invoke-virtual {v0, v1, v1}, Landroid/view/Window;->setFlags(II)V


            getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);
    """

    list_code_for_preventing_screen_capture = []
    path_code_for_preventing_screen_capture = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Landroid/view/Window;", "setFlags", "(I I)V")
    path_code_for_preventing_screen_capture = filteringEngine.filter_list_of_paths(d,
                                                                                   path_code_for_preventing_screen_capture)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_code_for_preventing_screen_capture):
        if (i.getResult()[1] is None) or (i.getResult()[2] is None):
            continue
        if (not isinstance(i.getResult()[1], (int, long))) or (not isinstance(i.getResult()[2], (int, long))):
            continue
        if (i.getResult()[1] & 0x2000) and (i.getResult()[2] & 0x2000):
            list_code_for_preventing_screen_capture.append(i.getPath())

    if list_code_for_preventing_screen_capture:
        writer.startWriter("HACKER_PREVENT_SCREENSHOT_CHECK", LEVEL_NOTICE,
                           "检查是否设置防截图功能",
                           """此应用程序的代码设置了防止屏幕截图。
               示例: getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);
               开发人员使用它来保护应用程序：""", ["Hacker"])
        for interesting_code in list_code_for_preventing_screen_capture:
            writer.show_Path(d, interesting_code)
    else:
        writer.startWriter("HACKER_PREVENT_SCREENSHOT_CHECK", LEVEL_INFO,
                           "检查是否设置防截图功能", "没有检测到这个应用程序有防止截图捕获的代码设置。", ["Hacker"])

    # ------------------------------------------------------------------------
    # Runtime exec checking:

    """
        Example Java code:
            1. Runtime.getRuntime().exec("");
            2. Runtime rr = Runtime.getRuntime(); Process p = rr.exec("ls -al");

        Example Bytecode code (The same bytecode for those two Java code):
            const-string v2, "ls -al"
            invoke-virtual {v1, v2}, Ljava/lang/Runtime;->exec(Ljava/lang/String;)Ljava/lang/Process;
    """

    list_Runtime_exec = []

    path_Runtime_exec = vmx.get_tainted_packages().search_class_methods_exact_match("Ljava/lang/Runtime;", "exec",
                                                                                    "(Ljava/lang/String;)Ljava/lang/Process;")
    path_Runtime_exec = filteringEngine.filter_list_of_paths(d, path_Runtime_exec)

    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_Runtime_exec):
        if i.getResult()[1] is None:
            continue
        if i.getResult()[1] == "su":
            list_Runtime_exec.append(i.getPath())

    if path_Runtime_exec:
        writer.startWriter("COMMAND", LEVEL_CRITICAL, "运行时命令检查",
                           "这个程序正在使用关键的函数 'Runtime.getRuntime().exec(\"... \")'。请确认以下代码段是无害的：",["Command"])

        writer.show_Paths(d, path_Runtime_exec)

        if list_Runtime_exec:
            writer.startWriter("COMMAND_SU", LEVEL_CRITICAL, "Runtime Critical Command Checking",
                               "检测到请求 \"root\" 权限的代码 'Runtime.getRuntime().exec(\"su\")'：", ["Command"])

            for path in list_Runtime_exec:
                writer.show_Path(d, path)
    else:
        writer.startWriter("COMMAND", LEVEL_INFO, "运行时命令检查", "这个程序没有使用关键函数 'Runtime.getRuntime().exec(\"...\")'。", ["Command"])

    # -------------------------------------------------------

    # HTTPS ALLOW_ALL_HOSTNAME_VERIFIER checking:

    """
        Example Java code:
            HttpsURLConnection.setDefaultHostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        Example Bytecode code (The same bytecode for those two Java code):	
            (1)
            sget-object v11, Lorg/apache/http/conn/ssl/SSLSocketFactory;->ALLOW_ALL_HOSTNAME_VERIFIER:Lorg/apache/http/conn/ssl/X509HostnameVerifier;
            invoke-static {v11}, Ljavax/net/ssl/HttpsURLConnection;->setDefaultHostnameVerifier(Ljavax/net/ssl/HostnameVerifier;)V

            (2)
               new-instance v11, Lcom/example/androidsslconnecttofbtest/MainActivity$2;
            invoke-direct {v11, p0}, Lcom/example/androidsslconnecttofbtest/MainActivity$2;-><init>(Lcom/example/androidsslconnecttofbtest/MainActivity;)V
            invoke-static {v11}, Ljavax/net/ssl/HttpsURLConnection;->setDefaultHostnameVerifier(Ljavax/net/ssl/HostnameVerifier;)V

        Scenario:
            https://www.google.com/  => Google (SSL certificate is valid, CN: www.google.com)
            https://60.199.175.18   => IP of Google (SSL certificate is invalid, See Chrome error message.
    """

    # (1)inner class checking

    # First, find out who calls it
    path_HOSTNAME_INNER_VERIFIER = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Ljavax/net/ssl/HttpsURLConnection;", "setDefaultHostnameVerifier", "(Ljavax/net/ssl/HostnameVerifier;)V")
    path_HOSTNAME_INNER_VERIFIER2 = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Lorg/apache/http/conn/ssl/SSLSocketFactory;", "setHostnameVerifier",
        "(Lorg/apache/http/conn/ssl/X509HostnameVerifier;)V")
    path_HOSTNAME_INNER_VERIFIER.extend(path_HOSTNAME_INNER_VERIFIER2)

    path_HOSTNAME_INNER_VERIFIER = filteringEngine.filter_list_of_paths(d, path_HOSTNAME_INNER_VERIFIER)

    dic_path_HOSTNAME_INNER_VERIFIER_new_instance = filteringEngine.get_class_container_dict_by_new_instance_classname_in_paths(
        d, analysis, path_HOSTNAME_INNER_VERIFIER, 1)  # parameter index 1

    # Second, find the called custom classes
    list_HOSTNAME_INNER_VERIFIER = []

    methods_hostnameverifier = get_method_ins_by_implement_interface_and_method(d, ["Ljavax/net/ssl/HostnameVerifier;"],"verify",
                                                                                "(Ljava/lang/String; Ljavax/net/ssl/SSLSession;)Z")
    for method in methods_hostnameverifier:
        register_analyzer = analysis.RegisterAnalyzerVM_ImmediateValue(method.get_instructions())
        if register_analyzer.get_ins_return_boolean_value():  # Has security problem
            list_HOSTNAME_INNER_VERIFIER.append(method)

    list_HOSTNAME_INNER_VERIFIER = filteringEngine.filter_list_of_methods(list_HOSTNAME_INNER_VERIFIER)

    if list_HOSTNAME_INNER_VERIFIER:

        output_string = """此应用允许自定义 HOSTNAME VERIFIER 接受所有通用名称（CN）。这是一个关键的漏洞，并允许攻击者在不知情的情况下使用他的有效证书进行 MITM 攻击。
案例： 
(1)http://osvdb.org/96411 
(2)http://www.wooyun.org/bugs/wooyun-2010-042710 
(3)http://www.wooyun.org/bugs/wooyun-2010-052339
查看 Google 文档： http://developer.android.com/training/articles/security-ssl.html (注意：替换 HostnameVerifier 可能非常危险). 
OWASP Mobile Top 10： https://www.owasp.org/index.php/Mobile_Top_10_2014-M3
http://goo.gl/BFb65r 

通用名称（CN）验证的重要性。
使用 Google Chrome:
 - https://www.google.com   => SSL证书有效
 - https://60.199.175.158/  => 这是google.com的IP地址，但CN不匹配，使证书无效。 您仍然可以访问Google.com，但现在您无法区分攻击者与正常用户

请检查这些方法中的代码："""

        writer.startWriter("SSL_CN1", LEVEL_CRITICAL, "SSL 检查（验证自定义类中的主机名）", output_string, ["SSL_Security"])

        for method in list_HOSTNAME_INNER_VERIFIER:
            writer.write(method.easy_print())

            # because one class may initialize by many new instances of it
            method_class_name = method.get_class_name()
            if method_class_name in dic_path_HOSTNAME_INNER_VERIFIER_new_instance:
                writer.show_Paths(d, dic_path_HOSTNAME_INNER_VERIFIER_new_instance[method_class_name])
    else:
        writer.startWriter("SSL_CN1", LEVEL_INFO, "SSL 检查（验证自定义类中的主机名）", "自定义 HOSTNAME VERIFIER 检查正确。", ["SSL_Security"])

    # (2)ALLOW_ALL_HOSTNAME_VERIFIER fields checking

    if "Lorg/apache/http/conn/ssl/AllowAllHostnameVerifier;" in dic_path_HOSTNAME_INNER_VERIFIER_new_instance:
        path_HOSTNAME_INNER_VERIFIER_new_instance = dic_path_HOSTNAME_INNER_VERIFIER_new_instance[
            "Lorg/apache/http/conn/ssl/AllowAllHostnameVerifier;"]
    else:
        path_HOSTNAME_INNER_VERIFIER_new_instance = None

    field_ALLOW_ALL_HOSTNAME_VERIFIER = vmx.get_tainted_field("Lorg/apache/http/conn/ssl/SSLSocketFactory;",
                                                              "ALLOW_ALL_HOSTNAME_VERIFIER",
                                                              "Lorg/apache/http/conn/ssl/X509HostnameVerifier;")

    if field_ALLOW_ALL_HOSTNAME_VERIFIER:
        filtered_ALLOW_ALL_HOSTNAME_VERIFIER_paths = filteringEngine.filter_list_of_variables(d, field_ALLOW_ALL_HOSTNAME_VERIFIER.get_paths())
    else:
        filtered_ALLOW_ALL_HOSTNAME_VERIFIER_paths = None

    if path_HOSTNAME_INNER_VERIFIER_new_instance or filtered_ALLOW_ALL_HOSTNAME_VERIFIER_paths:

        output_string = """此应用程序不检查SSL证书的CN（通用名称）的验证 ("ALLOW_ALL_HOSTNAME_VERIFIER" 字段或 "AllowAllHostnameVerifier" 类). 
这是一个关键的漏洞，并允许攻击者在不知情的情况下使用他的有效证书进行MITM攻击。
案例：
(1)http://osvdb.org/96411 
(2)http://www.wooyun.org/bugs/wooyun-2010-042710 
(3)http://www.wooyun.org/bugs/wooyun-2010-052339
Google 文档： http://developer.android.com/training/articles/security-ssl.html (Caution: Replacing HostnameVerifier can be very dangerous).
OWASP Mobile Top 10： https://www.owasp.org/index.php/Mobile_Top_10_2014-M3
http://goo.gl/BFb65r 

通用名称（CN）验证的重要性。
使用 Google Chrome:
 - https://www.google.com   => SSL证书有效
 - https://60.199.175.158/  => 这是google.com的IP地址，但CN不匹配，使证书无效。 您仍然可以访问Google.com，但现在您无法区分攻击者与正常用户

请检查这些方法中的代码："""

        writer.startWriter("SSL_CN2", LEVEL_CRITICAL, "SSL 检查（验证字段中的主机名）", output_string, ["SSL_Security"])

        if filtered_ALLOW_ALL_HOSTNAME_VERIFIER_paths:
            """
                Example code: 
                SSLSocketFactory factory = SSLSocketFactory.getSocketFactory();
                factory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
            """

            for path in filtered_ALLOW_ALL_HOSTNAME_VERIFIER_paths:
                writer.show_single_PathVariable(d, path)

        if path_HOSTNAME_INNER_VERIFIER_new_instance:
            """
                Example code: 
                SSLSocketFactory factory = SSLSocketFactory.getSocketFactory();
                factory.setHostnameVerifier(new AllowAllHostnameVerifier());
            """
            # For this one, the exclusion procedure is done on earlier
            writer.show_Paths(d, path_HOSTNAME_INNER_VERIFIER_new_instance)
    else:
        writer.startWriter("SSL_CN2", LEVEL_INFO, "SSL 检查（验证字段中的主机名）",
                           "严重漏洞 \"ALLOW_ALL_HOSTNAME_VERIFIER\" 字段设置或 \"AllowAllHostnameVerifier\" 类实例未找到。",
                           ["SSL_Security"])

    # -------------------------------------------------------

    # SSL getInsecure

    list_getInsecure = []
    path_getInsecure = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Landroid/net/SSLCertificateSocketFactory;", "getInsecure",
        "(I Landroid/net/SSLSessionCache;)Ljavax/net/ssl/SSLSocketFactory;")
    path_getInsecure = filteringEngine.filter_list_of_paths(d, path_getInsecure)

    if path_getInsecure:

        output_string = """Sockets created using this factory(insecure method "getInsecure") are vulnerable to man-in-the-middle attacks. 
Check the reference: http://developer.android.com/reference/android/net/SSLCertificateSocketFactory.html#getInsecure(int, android.net.SSLSessionCache). 
Please remove the insecure code:"""

        writer.startWriter("SSL_CN3", LEVEL_CRITICAL, "SSL 检查（不安全组件）", output_string, ["SSL_Security"])
        writer.show_Paths(d, path_getInsecure)
    else:
        writer.startWriter("SSL_CN3", LEVEL_INFO, "SSL 检查（不安全组件）", "没有通过不安全的方法 \"getInsecure\" 检测到 SSLSocketFactory。", ["SSL_Security"])

    # -------------------------------------------------------

    # HttpHost default scheme "http"

    """
        Check this paper to see why I designed this vector: "The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software"


        Java Example code:
            HttpHost target = new HttpHost(uri.getHost(), uri.getPort(), HttpHost.DEFAULT_SCHEME_NAME);

        Smali Example code:
            const-string v4, "http"
            invoke-direct {v0, v2, v3, v4}, Lorg/apache/http/HttpHost;-><init>(Ljava/lang/String; I Ljava/lang/String;)V
    """

    list_HttpHost_scheme_http = []
    path_HttpHost_scheme_http = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Lorg/apache/http/HttpHost;", "<init>", "(Ljava/lang/String; I Ljava/lang/String;)V")
    path_HttpHost_scheme_http = filteringEngine.filter_list_of_paths(d, path_HttpHost_scheme_http)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_HttpHost_scheme_http):
        if i.getResult()[3] is None:
            continue
        if (i.is_string(i.getResult()[3])) and ((i.getResult()[3]).lower() == "http"):
            list_HttpHost_scheme_http.append(i.getPath())

    if list_HttpHost_scheme_http:
        writer.startWriter("SSL_DEFAULT_SCHEME_NAME", LEVEL_CRITICAL, "SSL 检查（HttpHost）",
                           "这个应用使用 \"HttpHost\"， 但默认方案为 \"http\" 或 \"HttpHost.DEFAULT_SCHEME_NAME(http)\". 请更改为 \"https\"：",
                           ["SSL_Security"])

        for i in list_HttpHost_scheme_http:
            writer.show_Path(d, i)
    else:
        writer.startWriter("SSL_DEFAULT_SCHEME_NAME", LEVEL_INFO, "SSL 检查（HttpHost）",
                           "HttpHost 检查 DEFAULT_SCHEME_NAME 正确。", ["SSL_Security"])

    # ------------------------------------------------------------------------
    # WebViewClient onReceivedSslError errors

    # First, find out who calls setWebViewClient
    path_webviewClient_new_instance = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Landroid/webkit/WebView;", "setWebViewClient", "(Landroid/webkit/WebViewClient;)V")
    dic_webviewClient_new_instance = filteringEngine.get_class_container_dict_by_new_instance_classname_in_paths(d,
                                                                                                                 analysis,
                                                                                                                 path_webviewClient_new_instance,
                                                                                                                 1)

    # Second, find which class and method extends it
    list_webviewClient = []
    methods_webviewClient = get_method_ins_by_superclass_and_method(d, ["Landroid/webkit/WebViewClient;"],
                                                                    "onReceivedSslError",
                                                                    "(Landroid/webkit/WebView; Landroid/webkit/SslErrorHandler; Landroid/net/http/SslError;)V")
    for method in methods_webviewClient:
        if is_kind_string_in_ins_method(method, "Landroid/webkit/SslErrorHandler;->proceed()V"):
            list_webviewClient.append(method)

    list_webviewClient = filteringEngine.filter_list_of_methods(list_webviewClient)

    if list_webviewClient:
        writer.startWriter("SSL_WEBVIEW", LEVEL_CRITICAL, "SSL 检查（WebViewClient for WebView）",
                           """不要在扩展的 "WebViewClient" 方法中使用 "handler.proceed();"，即使SSL证书无效（MITM Vulnerability）也允许连接。
               参考:
               (1)WebView Exploitation: https://www.iseclab.org/papers/webview_leet13.pdf 
               (2)OWASP Mobile Top 10： https://www.owasp.org/index.php/Mobile_Top_10_2014-M3
               (3)https://jira.appcelerator.org/browse/TIMOB-4488
               漏洞代码：
               """, ["SSL_Security"])

        for method in list_webviewClient:
            writer.write(method.easy_print())

            # because one class may initialize by many new instances of it
            method_class_name = method.get_class_name()
            if method_class_name in dic_webviewClient_new_instance:
                writer.show_Paths(d, dic_webviewClient_new_instance[method_class_name])

    else:
        writer.startWriter("SSL_WEBVIEW", LEVEL_INFO, "SSL 检查（WebViewClient for WebView）",
                           "没有检测到 \"WebViewClient\"（MITM漏洞）的关键代码。", ["SSL_Security"])

    # ------------------------------------------------------------------------
    # WebView setJavaScriptEnabled - Potential XSS:

    """
        Java Example code:
            webView1 = (WebView)findViewById(R.id.webView1);
            webView1.setWebViewClient(new ExtendedWebView());
            WebSettings webSettings = webView1.getSettings();
            webSettings.setJavaScriptEnabled(true);

        Smali Example code:
            const/4 v1, 0x1
            invoke-virtual {v0, v1}, Landroid/webkit/WebSettings;->setJavaScriptEnabled(Z)V
    """

    list_setJavaScriptEnabled_XSS = []
    path_setJavaScriptEnabled_XSS = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Landroid/webkit/WebSettings;", "setJavaScriptEnabled", "(Z)V")
    path_setJavaScriptEnabled_XSS = filteringEngine.filter_list_of_paths(d, path_setJavaScriptEnabled_XSS)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_setJavaScriptEnabled_XSS):
        if i.getResult()[1] is None:
            continue
        if i.getResult()[1] == 0x1:
            list_setJavaScriptEnabled_XSS.append(i.getPath())

    if list_setJavaScriptEnabled_XSS:
        writer.startWriter("WEBVIEW_JS_ENABLED", LEVEL_WARNING, "WebView 潜在 XSS 攻击检查",
                           "在 WebView 中找到 \"setJavaScriptEnabled(true)\"，这可能会暴露在潜在的 XSS 攻击中。 请仔细检查网页代码：",
                           ["WebView"])
        for i in list_setJavaScriptEnabled_XSS:
            writer.show_Path(d, i)
    else:
        writer.startWriter("WEBVIEW_JS_ENABLED", LEVEL_INFO, "WebView 潜在 XSS 攻击检查",
                           "没有在 WebView 中检测到 \"setJavaScriptEnabled(true)\"。", ["WebView"])

    # ------------------------------------------------------------------------
    # HttpURLConnection bug checking:

    """
        Example Java code:
            private void disableConnectionReuseIfNecessary() {
                // Work around pre-Froyo bugs in HTTP connection reuse.
                if (Integer.parseInt(Build.VERSION.SDK) < Build.VERSION_CODES.FROYO) {
                    System.setProperty("http.keepAlive", "false");
                }
            }

        Example Bytecode code:
            const-string v0, "http.keepAlive"
            const-string v1, "false"
            invoke-static {v0, v1}, Ljava/lang/System;->setProperty(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;

    """

    if (int_min_sdk is not None) and (int_min_sdk <= 8):

        pkg_HttpURLConnection = vmx.get_tainted_packages().search_packages("Ljava/net/HttpURLConnection;")
        pkg_HttpURLConnection = filteringEngine.filter_list_of_paths(d, pkg_HttpURLConnection)

        # Check only when using the HttpURLConnection
        if pkg_HttpURLConnection:

            list_pre_Froyo_HttpURLConnection = []
            path_pre_Froyo_HttpURLConnection = vmx.get_tainted_packages().search_class_methods_exact_match(
                "Ljava/lang/System;", "setProperty", "(Ljava/lang/String; Ljava/lang/String;)Ljava/lang/String;")
            path_pre_Froyo_HttpURLConnection = filteringEngine.filter_list_of_paths(d, path_pre_Froyo_HttpURLConnection)

            has_http_keepAlive_Name = False
            has_http_keepAlive_Value = False

            for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_pre_Froyo_HttpURLConnection):
                if (i.getResult()[0] == "http.keepAlive"):
                    has_http_keepAlive_Name = True
                    list_pre_Froyo_HttpURLConnection.append(i.getPath())  # Only list the "false" one
                    if (i.getResult()[1] == "false"):
                        has_http_keepAlive_Value = True
                        break

            if has_http_keepAlive_Name:
                if has_http_keepAlive_Value:
                    writer.startWriter("HTTPURLCONNECTION_BUG", LEVEL_INFO, "HttpURLConnection Android Bug 检查",
                                       "\"HttpURLConnection\" 的系统属性 \"http.keepAlive\" 设置正确。")

                else:
                    output_string = """您应该将 System 属性 "http.keepAlive" 设置为 "false"
你正在使用 "HttpURLConnection"。 在 Android 2.2 (Froyo) 之前，"HttpURLConnection" 有一些 Bug。
特别是，在可读的 InputStream 上调用 close() 可能会中断连接池。通过禁用连接池来解决此问题：
参考：
 (1)http://developer.android.com/reference/java/net/HttpURLConnection.html
 (2)http://android-developers.blogspot.tw/2011/09/androids-http-clients.html"""
                    writer.startWriter("HTTPURLCONNECTION_BUG", LEVEL_NOTICE, "HttpURLConnection Android Bug 检查", output_string)

                    writer.show_Paths(d, list_pre_Froyo_HttpURLConnection)  # Notice: list_pre_Froyo_HttpURLConnection
            else:
                output_string = """你正在使用 "HttpURLConnection"。 在 Android 2.2 (Froyo) 之前，"HttpURLConnection" 有一些 Bug。
特别是，在可读的 InputStream 上调用 close() 可能会中断连接池。通过禁用连接池来解决此问题：
参考：
 (1)http://developer.android.com/reference/java/net/HttpURLConnection.html
 (2)http://android-developers.blogspot.tw/2011/09/androids-http-clients.html"""

                writer.startWriter("HTTPURLCONNECTION_BUG", LEVEL_NOTICE, "HttpURLConnection Android Bug 检查", output_string)
                # Make it optional to list library
                writer.show_Paths(d, pkg_HttpURLConnection)  # Notice: pkg_HttpURLConnection

        else:
            writer.startWriter("HTTPURLCONNECTION_BUG", LEVEL_INFO, "HttpURLConnection Android Bug 检查",
                               "忽略检查 \"http.keepAlive\" 因为您没有使用 \"HttpURLConnection\"。")

    else:
        writer.startWriter("HTTPURLCONNECTION_BUG", LEVEL_INFO, "HttpURLConnection Android Bug 检查",
                           "忽略检查 \"http.keepAlive\" 因为您没有使用 \"HttpURLConnection\" 并且 min_Sdk > 8。")

    # ------------------------------------------------------------------------
    # SQLiteDatabase - beginTransactionNonExclusive() checking:

    if (int_min_sdk is not None) and (int_min_sdk < 11):

        path_SQLiteDatabase_beginTransactionNonExclusive = vmx.get_tainted_packages().search_class_methods_exact_match(
            "Landroid/database/sqlite/SQLiteDatabase;", "beginTransactionNonExclusive", "()V")
        path_SQLiteDatabase_beginTransactionNonExclusive = filteringEngine.filter_list_of_paths(d,
                                                                                                path_SQLiteDatabase_beginTransactionNonExclusive)

        if path_SQLiteDatabase_beginTransactionNonExclusive:
            output_string = ""
            output_string += ("检测到您正在 \"SQLiteDatabase\" 中使用 \"beginTransactionNonExclusive\"，但是您的 min sdk 支持低至" + str(int_min_sdk) + "。")
            output_string += ("API < 11 时并不支持 \"beginTransactionNonExclusive\"， 请确保在早期版本中使用 \"beginTransaction\"。")
            output_string += ("参考： http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#beginTransactionNonExclusive()")
            writer.startWriter("DB_DEPRECATED_USE1", LEVEL_CRITICAL, "SQLiteDatabase 事务已弃用检查", output_string, ["Database"])

            writer.show_Paths(d, path_SQLiteDatabase_beginTransactionNonExclusive)
        else:
            writer.startWriter("DB_DEPRECATED_USE1", LEVEL_INFO, "SQLiteDatabase 事务已弃用检查",
                               "忽略使用 \"SQLiteDatabase:beginTransactionNonExclusive\" 因为您没有使用它。", ["Database"])
    else:
        writer.startWriter("DB_DEPRECATED_USE1", LEVEL_INFO, "SQLiteDatabase 事务已弃用检查",
                           "忽略使用 \"SQLiteDatabase:beginTransactionNonExclusive\" 因为您使用的 minSdk >= 11。", ["Database"])

    # ------------------------------------------------------------------------

    """
        MODE_WORLD_READABLE or MODE_WORLD_WRITEABLE checking:

        MODE_WORLD_READABLE = 1
        MODE_WORLD_WRITEABLE = 2
        MODE_WORLD_READABLE + MODE_WORLD_WRITEABLE = 3

        http://jimmy319.blogspot.tw/2011/07/android-internal-storagefile-io.html

        Example Java Code:
            FileOutputStream outputStream = openFileOutput("Hello_World", Activity.MODE_WORLD_READABLE);

        Example Smali Code:
            const-string v3, "Hello_World"
            const/4 v4, 0x1
            invoke-virtual {p0, v3, v4}, Lcom/example/android_mode_world_testing/MainActivity;->openFileOutput(Ljava/lang/String;I)Ljava/io/FileOutputStream;
    """

    # Get a list of 'PathP' objects that are vulnerabilities
    list_path_openOrCreateDatabase = []
    list_path_openOrCreateDatabase2 = []
    list_path_getDir = []
    list_path_getSharedPreferences = []
    list_path_openFileOutput = []

    path_openOrCreateDatabase = vmx.get_tainted_packages().search_methods_exact_match("openOrCreateDatabase",
                                                                                      "(Ljava/lang/String; I Landroid/database/sqlite/SQLiteDatabase$CursorFactory;)Landroid/database/sqlite/SQLiteDatabase;")
    path_openOrCreateDatabase = filteringEngine.filter_list_of_paths(d, path_openOrCreateDatabase)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_openOrCreateDatabase):
        if (0x1 <= i.getResult()[2] <= 0x3):
            list_path_openOrCreateDatabase.append(i.getPath())

    path_openOrCreateDatabase2 = vmx.get_tainted_packages().search_methods_exact_match("openOrCreateDatabase",
                                                                                       "(Ljava/lang/String; I Landroid/database/sqlite/SQLiteDatabase$CursorFactory; Landroid/database/DatabaseErrorHandler;)Landroid/database/sqlite/SQLiteDatabase;")
    path_openOrCreateDatabase2 = filteringEngine.filter_list_of_paths(d, path_openOrCreateDatabase2)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_openOrCreateDatabase2):
        if (0x1 <= i.getResult()[2] <= 0x3):
            list_path_openOrCreateDatabase2.append(i.getPath())

    path_getDir = vmx.get_tainted_packages().search_methods_exact_match("getDir",
                                                                        "(Ljava/lang/String; I)Ljava/io/File;")
    path_getDir = filteringEngine.filter_list_of_paths(d, path_getDir)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_getDir):
        if (0x1 <= i.getResult()[2] <= 0x3):
            list_path_getDir.append(i.getPath())

    path_getSharedPreferences = vmx.get_tainted_packages().search_methods_exact_match("getSharedPreferences",
                                                                                      "(Ljava/lang/String; I)Landroid/content/SharedPreferences;")
    path_getSharedPreferences = filteringEngine.filter_list_of_paths(d, path_getSharedPreferences)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_getSharedPreferences):
        if (0x1 <= i.getResult()[2] <= 0x3):
            list_path_getSharedPreferences.append(i.getPath())

    path_openFileOutput = vmx.get_tainted_packages().search_methods_exact_match("openFileOutput",
                                                                                "(Ljava/lang/String; I)Ljava/io/FileOutputStream;")
    path_openFileOutput = filteringEngine.filter_list_of_paths(d, path_openFileOutput)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_openFileOutput):
        if (0x1 <= i.getResult()[2] <= 0x3):
            list_path_openFileOutput.append(i.getPath())

    if list_path_openOrCreateDatabase or list_path_openOrCreateDatabase2 or list_path_getDir or list_path_getSharedPreferences or list_path_openFileOutput:

        writer.startWriter("MODE_WORLD_READABLE_OR_MODE_WORLD_WRITEABLE", LEVEL_CRITICAL, "应用程序沙箱权限检查",
                           "找到安全问题 \"MODE_WORLD_READABLE\" 或者 \"MODE_WORLD_WRITEABLE\" (请查看： https://www.owasp.org/index.php/Mobile_Top_10_2014-M2)：")

        if list_path_openOrCreateDatabase:
            writer.write("[openOrCreateDatabase - 3 params]")
            for i in list_path_openOrCreateDatabase:
                writer.show_Path(d, i)
            writer.write("--------------------------------------------------")
        if list_path_openOrCreateDatabase2:
            writer.write("[openOrCreateDatabase - 4 params]")
            for i in list_path_openOrCreateDatabase2:
                writer.show_Path(d, i)
            writer.write("--------------------------------------------------")
        if list_path_getDir:
            writer.write("[getDir]")
            for i in list_path_getDir:
                writer.show_Path(d, i)
            writer.write("--------------------------------------------------")
        if list_path_getSharedPreferences:
            writer.write("[getSharedPreferences]")
            for i in list_path_getSharedPreferences:
                writer.show_Path(d, i)
            writer.write("--------------------------------------------------")
        if list_path_openFileOutput:
            writer.write("[openFileOutput]")
            for i in list_path_openFileOutput:
                writer.show_Path(d, i)
            writer.write("--------------------------------------------------")

    else:
        writer.startWriter("MODE_WORLD_READABLE_OR_MODE_WORLD_WRITEABLE", LEVEL_INFO, "应用程序沙箱权限检查",
                           "在 'openOrCreateDatabase' 或 'openOrCreateDatabase2' 或 'getDir' 或 'getSharedPreferences' 或 'openFileOutput' 中没有找到安全问题： \"MODE_WORLD_READABLE\" 或 \"MODE_WORLD_WRITEABLE\"。")

    # ------------------------------------------------------------------------
    # List all native method

    """
        Example:
            const-string v0, "AndroBugsNdk"
            invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
    """

    cm = d.get_class_manager()

    dic_NDK_library_classname_to_ndkso_mapping = {}
    list_NDK_library_classname_to_ndkso_mapping = []
    path_NDK_library_classname_to_ndkso_mapping = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Ljava/lang/System;", "loadLibrary", "(Ljava/lang/String;)V")
    path_NDK_library_classname_to_ndkso_mapping = filteringEngine.filter_list_of_paths(d,
                                                                                       path_NDK_library_classname_to_ndkso_mapping)
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_NDK_library_classname_to_ndkso_mapping):
        if (i.getResult()[0] is None) or (not i.is_string(0)):
            continue
        so_file_name = i.getResult()[0]
        src_class_name, src_method_name, src_descriptor = i.getPath().get_src(cm)
        if src_class_name is None:
            continue
        if src_class_name not in dic_NDK_library_classname_to_ndkso_mapping:
            dic_NDK_library_classname_to_ndkso_mapping[src_class_name] = []

        dic_NDK_library_classname_to_ndkso_mapping[src_class_name].append("lib"+str(i.getResult()[0])+".so")
        list_NDK_library_classname_to_ndkso_mapping.append(["lib"+(str(i.getResult()[0]))+".so", i.getPath()])

    if list_NDK_library_classname_to_ndkso_mapping:
        writer.startWriter("NATIVE_LIBS_LOADING", LEVEL_NOTICE, "本地库加载检查", "检测到本地库加载代码 (System.loadLibrary(...))：")

        for ndk_location, path in list_NDK_library_classname_to_ndkso_mapping:
            writer.write("[" + ndk_location + "]")
            writer.show_Path(d, path)
    else:
        writer.startWriter("NATIVE_LIBS_LOADING", LEVEL_INFO, "本地库加载检查", "没有本地库加载。")

    dic_native_methods = {}
    regexp_sqlcipher_database_class = re.compile(".*/SQLiteDatabase;")
    for method in d.get_methods():
        if method.is_native():
            class_name = method.get_class_name()
            if filteringEngine.is_class_name_not_in_exclusion(class_name):
                if class_name not in dic_native_methods:
                    dic_native_methods[class_name] = []
                dic_native_methods[class_name].append(method)

            # <<Essential_Block_1>>
            if regexp_sqlcipher_database_class.match(class_name):
                if (method.get_name() == "dbopen") or (
                    method.get_name() == "dbclose"):  # Make it to 2 conditions to add efficiency
                    isUsingSQLCipher = True  # This is for later use


    # Framework Detection: Bangcle

    is_using_Framework_Bangcle = False
    is_using_Framework_ijiami = False
    is_using_Framework_MonoDroid = False


    # Display only when using the Framework (Notice: This vector depends on "List all native method")
    if list_NDK_library_classname_to_ndkso_mapping:
        android_name_in_application_tag = a.get_android_name_in_application_tag()
        list_NDK_library_classname_to_ndkso_mapping_only_ndk_location = []
        for ndk_location, path in list_NDK_library_classname_to_ndkso_mapping:
            list_NDK_library_classname_to_ndkso_mapping_only_ndk_location.append(ndk_location)

        if ("libsecexe.so" in list_NDK_library_classname_to_ndkso_mapping_only_ndk_location):
            if (android_name_in_application_tag == "com.secapk.wrapper.ApplicationWrapper"):
                is_using_Framework_Bangcle = True
            else:
                path_secapk = vmx.get_tainted_packages().search_class_methods_exact_match("Lcom/secapk/wrapper/ACall;",
                                                                                          "getACall",
                                                                                          "()Lcom/secapk/wrapper/ACall;")
                if path_secapk:
                    is_using_Framework_Bangcle = True

        if (len(list_NDK_library_classname_to_ndkso_mapping_only_ndk_location) == 2):
            if ("libexec.so" in list_NDK_library_classname_to_ndkso_mapping_only_ndk_location) and (
                "libexecmain.so" in list_NDK_library_classname_to_ndkso_mapping_only_ndk_location):
                paths_ijiami_signature = vmx.get_tainted_packages().search_class_methods_exact_match(
                    "Lcom/shell/NativeApplication;", "load", "(Landroid/app/Application; Ljava/lang/String;)Z")
                if paths_ijiami_signature:
                    is_using_Framework_ijiami = True

        if (android_name_in_application_tag == "mono.android.app.Application"):
            for name, _, _ in a.get_files_information():
                if (name == "lib/armeabi-v7a/libmonodroid.so") or (name == "lib/armeabi/libmonodroid.so"):
                    is_using_Framework_MonoDroid = True
                    break

        if is_using_Framework_Bangcle:
            writer.startWriter("FRAMEWORK_BANGCLE", LEVEL_NOTICE, "加密框架 - Bangcle",
                               "使用了 Bangcle 加密框架(http://www.bangcle.com/)。",
                               ["Framework"])
        if is_using_Framework_ijiami:
            writer.startWriter("FRAMEWORK_IJIAMI", LEVEL_NOTICE, "加密框架 - Ijiami",
                               "使用了 Ijiami 加密框架(http://www.ijiami.cn/)。",
                               ["Framework"])

    if is_using_Framework_MonoDroid:
        writer.startWriter("FRAMEWORK_MONODROID", LEVEL_NOTICE, "框架 - MonoDroid",
                           "使用了 MonoDroid 框架(http://xamarin.com/android)。", ["Framework"])
    else:
        writer.startWriter("FRAMEWORK_MONODROID", LEVEL_INFO, "框架 - MonoDroid",
                           "没有使用 MonoDroid 框架(http://xamarin.com/android)。", ["Framework"])

    # ------------------------------------------------------------------------
    # Detect dynamic code loading

    paths_DexClassLoader = vmx.get_tainted_packages().search_methods("Ldalvik/system/DexClassLoader;", ".", ".")
    paths_DexClassLoader = filteringEngine.filter_list_of_paths(d, paths_DexClassLoader)
    if paths_DexClassLoader:
        writer.startWriter("DYNAMIC_CODE_LOADING", LEVEL_WARNING, "动态代码加载", "检测到动态代码加载 (DexClassLoader)：")
        writer.show_Paths(d, paths_DexClassLoader)
    else:
        writer.startWriter("DYNAMIC_CODE_LOADING", LEVEL_INFO, "动态代码加载",
                           "没有检测到动态代码加载 (DexClassLoader)。")

    # ------------------------------------------------------------------------
    # Get External Storage Directory access invoke

    paths_ExternalStorageAccess = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Landroid/os/Environment;", "getExternalStorageDirectory", "()Ljava/io/File;")
    paths_ExternalStorageAccess = filteringEngine.filter_list_of_paths(d, paths_ExternalStorageAccess)
    if paths_ExternalStorageAccess:
        writer.startWriter("EXTERNAL_STORAGE", LEVEL_WARNING, "外部存储访问",
                           "找到外部存储访问（记住不要将重要文件写入外部存储）：")
        writer.show_Paths(d, paths_ExternalStorageAccess)
    else:
        writer.startWriter("EXTERNAL_STORAGE", LEVEL_INFO, "外部存储访问",
                           "没有找到外部存储访问。")

    # ------------------------------------------------------------------------
    # Android Fragment Vulnerability (prior to Android 4.4)

    prog = re.compile("Landroid/support/v(\d*)/app/Fragment;")
    REGEXP_EXCLUDE_CLASSESd_fragment_class = re.compile("(Landroid/support/)|(Lcom/actionbarsherlock/)")
    list_Fragment = []
    has_any_fragment = False
    for cls in d.get_classes():
        if (cls.get_superclassname() == "Landroid/app/Fragment;") or prog.match(cls.get_superclassname()):
            if not REGEXP_EXCLUDE_CLASSESd_fragment_class.match(cls.get_name()):
                # Exclude the classes from library itself to make the finding more precise and to check the user really use fragment, not just include the libs
                has_any_fragment = True
                list_Fragment.append(cls.get_name())

    list_Fragment_vulnerability_NonMethod_classes = []
    list_Fragment_vulnerability_Method_OnlyReturnTrue_methods = []
    list_Fragment_vulnerability_Method_NoIfOrSwitch_methods = []

    list_Fragment = filteringEngine.filter_list_of_classes(list_Fragment)

    if list_Fragment:
        for cls in d.get_classes():
            if (cls.get_superclassname() == "Landroid/preference/PreferenceActivity;") or (
                cls.get_superclassname() == "Lcom/actionbarsherlock/app/SherlockPreferenceActivity;"):
                boolHas_isValidFragment = False
                method_isValidFragment = None
                for method in cls.get_methods():
                    if (method.get_name() == "isValidFragment") and (
                        method.get_descriptor() == "(Ljava/lang/String;)Z"):
                        boolHas_isValidFragment = True
                        method_isValidFragment = method
                        break
                if boolHas_isValidFragment:
                    register_analyzer = analysis.RegisterAnalyzerVM_ImmediateValue(
                        method_isValidFragment.get_instructions())
                    if register_analyzer.get_ins_return_boolean_value():
                        list_Fragment_vulnerability_Method_OnlyReturnTrue_methods.append(method_isValidFragment)
                    else:
                        if not register_analyzer.has_if_or_switch_instructions():  # do not have "if" or "switch" op in instructions of method
                            list_Fragment_vulnerability_Method_NoIfOrSwitch_methods.append(method_isValidFragment)
                else:
                    list_Fragment_vulnerability_NonMethod_classes.append(cls.get_name())

    list_Fragment_vulnerability_NonMethod_classes = filteringEngine.filter_list_of_classes(
        list_Fragment_vulnerability_NonMethod_classes)
    list_Fragment_vulnerability_Method_OnlyReturnTrue_methods = filteringEngine.filter_list_of_methods(
        list_Fragment_vulnerability_Method_OnlyReturnTrue_methods)
    list_Fragment_vulnerability_Method_NoIfOrSwitch_methods = filteringEngine.filter_list_of_methods(
        list_Fragment_vulnerability_Method_NoIfOrSwitch_methods)

    if list_Fragment_vulnerability_NonMethod_classes or list_Fragment_vulnerability_Method_OnlyReturnTrue_methods or list_Fragment_vulnerability_Method_NoIfOrSwitch_methods:

        output_string = """"Fragment" 或 "ActionbarSherlock" 的片段在 Android 4.4(API 19) 之前具有严重的漏洞。
请检查：
(1)http://developer.android.com/reference/android/os/Build.VERSION_CODES.html#KITKAT 
(2)http://developer.android.com/reference/android/preference/PreferenceActivity.html#isValidFragment(java.lang.String) 
(3)http://stackoverflow.com/questions/19973034/isvalidfragment-android-api-19 
(4)http://securityintelligence.com/new-vulnerability-android-framework-fragment-injection/ 
(5)http://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf 
(6)https://cureblog.de/2013/11/cve-2013-6271-remove-device-locks-from-android-phone/ """

        writer.startWriter("FRAGMENT_INJECTION", LEVEL_CRITICAL, "漏洞片段检查", output_string, None, "BID 64208, CVE-2013-6271")

        if list_Fragment_vulnerability_NonMethod_classes:
            if int_target_sdk >= 19:
                # You must override. Otherwise, it always throws Exception
                writer.write(
                    "You MUST override 'isValidFragment' method in every \"PreferenceActivity\" class to avoid Exception throwing in Android 4.4:")
                for i in list_Fragment_vulnerability_NonMethod_classes:  # Notice: Each element in the list is NOT method, but String
                    writer.write("    " + i)
            else:
                # You must override. Otherwise, it always throws Exception
                writer.write(
                    "These \"PreferenceActivity\" classes may be vulnerable because they do not override 'isValidFragment' method (If you do not load any fragment in the PreferenceActivity, please still override 'isValidFragment' method and only return \"false\" to secure your app in the future changes) :")
                for i in list_Fragment_vulnerability_NonMethod_classes:  # Notice: Each element in the list is NOT method, but String
                    writer.write("    " + i)

        if list_Fragment_vulnerability_Method_OnlyReturnTrue_methods:
            writer.write(
                "You override 'isValidFragment' and only return \"true\" in those classes. You should use \"if\" condition to check whether the fragment is valid:")
            writer.write(
                "(Example code: http://stackoverflow.com/questions/19973034/isvalidfragment-android-api-19/20139823#20139823)")
            for method in list_Fragment_vulnerability_Method_OnlyReturnTrue_methods:
                writer.write("    " + method.easy_print())

        if list_Fragment_vulnerability_Method_NoIfOrSwitch_methods:
            writer.write(
                "Please make sure you check the valid fragment inside the overridden 'isValidFragment' method:")
            for method in list_Fragment_vulnerability_Method_NoIfOrSwitch_methods:
                writer.write("    " + method.easy_print())

        if list_Fragment:
            writer.write("All of the potential vulnerable \"fragment\":")
            for i in list_Fragment:
                writer.write("    " + i)

    else:
        writer.startWriter("FRAGMENT_INJECTION", LEVEL_INFO, "漏洞片段检查",
                           "没有检测到 \"Fragment\" 的动态加载到 \"PreferenceActivity\" 或 \"SherlockPreferenceActivity\" 的漏洞。",
                           None, "BID 64208, CVE-2013-6271")

    # ------------------------------------------------------------------------
    # Find all "dangerous" permission

    """
        android:permission
        android:readPermission (for ContentProvider)
        android:writePermission (for ContentProvider)
    """

    # Get a mapping dictionary
    PermissionName_to_ProtectionLevel = a.get_PermissionName_to_ProtectionLevel_mapping()

    dangerous_custom_permissions = []
    for name, protectionLevel in PermissionName_to_ProtectionLevel.items():
        if protectionLevel == 1:
            dangerous_custom_permissions.append(name)

    if dangerous_custom_permissions:

        writer.startWriter("PERMISSION_DANGEROUS", LEVEL_CRITICAL,
                           "AndroidManifest 危险保护权限检查",
                           """以下类的保护级别为“危险”，允许任何其他应用程序访问此权限(AndroidManifest.xml)。 
               该应用程序应该使用 \"Signature\" 或 \"signatureOrSystem\" 的 \"android：protectLevel\" 声明权限，以便其他应用程序无法注册和接收此应用程序的消息。
               android：protectLevel = "Signature" 确保具有请求权限的应用程序必须使用与声明权限的应用程序相同的证书进行签名。
               参考相关案例： http://www.wooyun.org/bugs/wooyun-2010-039697  
               请检查这些权限：""")

        for class_name in dangerous_custom_permissions:
            writer.write(class_name)

            who_use_this_permission = get_all_components_by_permission(a.get_AndroidManifest(), class_name)
            who_use_this_permission = collections.OrderedDict(sorted(who_use_this_permission.items()))
            if who_use_this_permission:
                for key, valuelist in who_use_this_permission.items():
                    for list_item in valuelist:
                        writer.write("    -> used by (" + key + ") " + a.format_value(list_item))
    else:
        writer.startWriter("PERMISSION_DANGEROUS", LEVEL_INFO,
                           "AndroidManifest 危险保护权限检查", "没有找到危险等级的自定义权限(AndroidManifest.xml)。")

    # ------------------------------------------------------------------------
    # Find all "normal" or default permission

    normal_or_default_custom_permissions = []
    for name, protectionLevel in PermissionName_to_ProtectionLevel.items():
        if protectionLevel == 0:
            normal_or_default_custom_permissions.append(name)

    if normal_or_default_custom_permissions:
        writer.startWriter("PERMISSION_NORMAL", LEVEL_WARNING,
                           "AndroidManifest 正常保护权限检查",
                           """以下类的保护级别为 \"normal\" 或默认值(AndroidManifest.xml)。
               该应用程序应该使用 \"Signature\" 或 \"signatureOrSystem\" 的 \"android：protectLevel\" 声明权限，以便其他应用程序无法注册和接收此应用程序的消息。 
               android:protectionLevel="signature" 确保具有请求权限的应用程序必须使用与声明权限的应用程序相同的证书进行签名。
               请确保这些权限真的需要导出，否则改为 \"Signature\" 或 \"signatureOrSystem\" 保护级别。""")
        for class_name in normal_or_default_custom_permissions:
            writer.write(class_name)
            who_use_this_permission = get_all_components_by_permission(a.get_AndroidManifest(), class_name)
            who_use_this_permission = collections.OrderedDict(sorted(who_use_this_permission.items()))
            if who_use_this_permission:
                for key, valuelist in who_use_this_permission.items():
                    for list_item in valuelist:
                        writer.write("    -> used by (" + key + ") " + a.format_value(list_item))
    else:
        writer.startWriter("PERMISSION_NORMAL", LEVEL_INFO,
                           "AndroidManifest 正常保护权限检查",
                           "没有找到默认或 \"normal\" 保护级别定制权限。")

    # ------------------------------------------------------------------------

    # Lost "android:" prefix in exported components

    list_lost_exported_components = []
    find_tags = ["activity", "activity-alias", "service", "receiver", "provider"]
    xml = a.get_AndroidManifest()
    for tag in find_tags:
        for item in xml.getElementsByTagName(tag):
            name = item.getAttribute("android:name")
            exported = item.getAttribute("exported")
            if (not isNullOrEmptyString(name)) and (not isNullOrEmptyString(exported)):
                list_lost_exported_components.append((tag, name))

    if list_lost_exported_components:
        writer.startWriter("PERMISSION_NO_PREFIX_EXPORTED", LEVEL_CRITICAL,
                           "AndroidManifest 导出丢失的前缀检查",
                           """发现导出的组件忘了添加 "android:" 前缀（AndroidManifest.xml）。
               相关案例: (1)http://blog.curesec.com/article/blog/35.html
                        (2)http://safe.baidu.com/2014-07/cve-2013-6272.html
                        (3)http://blogs.360.cn/360mobile/2014/07/08/cve-2013-6272/""", None, "CVE-2013-6272")

        for tag, name in list_lost_exported_components:
            writer.write(("%10s => %s") % (tag, a.format_value(name)))

    else:
        writer.startWriter("PERMISSION_NO_PREFIX_EXPORTED", LEVEL_INFO, "AndroidManifest 导出丢失的前缀检查",
                           "没有导出的组件忘了添加 \"android:\" 前缀。", None, "CVE-2013-6272")

    # ------------------------------------------------------------------------

    # "exported" checking (activity, activity-alias, service, receiver):

    list_ready_to_check = []
    find_tags = ["activity", "activity-alias", "service", "receiver"]
    xml = a.get_AndroidManifest()
    for tag in find_tags:
        for item in xml.getElementsByTagName(tag):
            name = item.getAttribute("android:name")
            exported = item.getAttribute("android:exported")
            permission = item.getAttribute("android:permission")
            has_any_actions_in_intent_filter = False
            if (not isNullOrEmptyString(name)) and (exported.lower() != "false"):

                is_ready_to_check = False
                is_launcher = False
                has_any_non_google_actions = False
                isSyncAdapterService = False
                for sitem in item.getElementsByTagName("intent-filter"):
                    for ssitem in sitem.getElementsByTagName("action"):
                        has_any_actions_in_intent_filter = True

                        action_name = ssitem.getAttribute("android:name")
                        if (not action_name.startswith("android.")) and (not action_name.startswith("com.android.")):
                            has_any_non_google_actions = True

                        if (action_name == "android.content.SyncAdapter"):
                            isSyncAdapterService = True

                    for ssitem in sitem.getElementsByTagName("category"):
                        category_name = ssitem.getAttribute("android:name")
                        if category_name == "android.intent.category.LAUNCHER":
                            is_launcher = True

                # exported="true" or exported not set
                if exported == "":
                    if has_any_actions_in_intent_filter:
                        # CHECK
                        is_ready_to_check = True

                elif exported.lower() == "true":  # exported = "true"
                    # CHECK
                    is_ready_to_check = True

                if (is_ready_to_check) and (not is_launcher):
                    list_ready_to_check.append((tag, a.format_value(name), exported, permission,
                                                has_any_non_google_actions, has_any_actions_in_intent_filter,
                                                isSyncAdapterService))
    # ------------------------------------------------------------------------
    # CHECK procedure
    list_implicit_service_components = []

    list_alerting_exposing_components_NonGoogle = []
    list_alerting_exposing_components_Google = []
    for i in list_ready_to_check:
        component = i[0]
        permission = i[3]
        hasAnyNonGoogleActions = i[4]
        has_any_actions_in_intent_filter = i[5]
        isSyncAdapterService = i[6]
        is_dangerous = False
        if permission == "":  # permission is not set
            is_dangerous = True
        else:  # permission is set
            if permission in PermissionName_to_ProtectionLevel:
                protectionLevel = PermissionName_to_ProtectionLevel[permission]
                if (protectionLevel == 0) or (protectionLevel == 1):
                    is_dangerous = True
                    # else: #cannot find the mapping permission
                    # 	is_dangerous = True

        if is_dangerous:
            if (component == "service") and (has_any_actions_in_intent_filter) and (not isSyncAdapterService):
                list_implicit_service_components.append(i[1])

            if hasAnyNonGoogleActions:
                if i not in list_alerting_exposing_components_NonGoogle:
                    list_alerting_exposing_components_NonGoogle.append(i)
            else:
                if i not in list_alerting_exposing_components_Google:
                    list_alerting_exposing_components_Google.append(i)

    if list_alerting_exposing_components_NonGoogle or list_alerting_exposing_components_Google:
        if list_alerting_exposing_components_NonGoogle:
            writer.startWriter("PERMISSION_EXPORTED", LEVEL_WARNING, "AndroidManifest 导出组件检查",
                               """找到 "exported" 组件（启动器除外）用于接收外部应用程序的操作(AndroidManifest.xml)。 
               这些组件可以由其他应用程序初始化。如果不想，您应该将属性添加或修改为[exported = "false"]。
               您还可以使用 "Signature" 或更高级别的保护级别的自定义权限来保护它，并在 "android:permission" 属性中指定。""")

            for i in list_alerting_exposing_components_NonGoogle:
                writer.write(("%10s => %s") % (i[0], i[1]))

        if list_alerting_exposing_components_Google:
            writer.startWriter("PERMISSION_EXPORTED_GOOGLE", LEVEL_NOTICE, "AndroidManifest 导出组件检查 2",
                               "发现 \"exported\" 组件（启动器除外）用于接收 Google 的 \"Android\" 操作(AndroidManifest.xml)：")

            for i in list_alerting_exposing_components_Google:
                writer.write(("%10s => %s") % (i[0], i[1]))
    else:
        writer.startWriter("PERMISSION_EXPORTED", LEVEL_INFO, "AndroidManifest 导出组件检查",
                           "没有导出的组件（启动器除外）用于接收 Android 或外部应用程序的操作(AndroidManifest.xml)。")

    # ------------------------------------------------------------------------
    # "exported" checking (provider):
    # android:readPermission, android:writePermission, android:permission
    list_ready_to_check = []

    xml = a.get_AndroidManifest()
    for item in xml.getElementsByTagName("provider"):
        name = item.getAttribute("android:name")
        exported = item.getAttribute("android:exported")

        if (not isNullOrEmptyString(name)) and (exported.lower() != "false"):
            # exported is only "true" or non-set
            permission = item.getAttribute("android:permission")
            readPermission = item.getAttribute("android:readPermission")
            writePermission = item.getAttribute("android:writePermission")
            has_exported = True if (exported != "") else False

            list_ready_to_check.append(
                (a.format_value(name), exported, permission, readPermission, writePermission, has_exported))

    list_alerting_exposing_providers_no_exported_setting = []  # providers that Did not set exported
    list_alerting_exposing_providers = []  # provider with "true" exported
    for i in list_ready_to_check:  # only exist "exported" provider or not set
        exported = i[1]
        permission = i[2]
        readPermission = i[3]
        writePermission = i[4]
        has_exported = i[5]

        is_dangerous = False
        list_perm = []
        if permission != "":
            list_perm.append(permission)
        if readPermission != "":
            list_perm.append(readPermission)
        if writePermission != "":
            list_perm.append(writePermission)

        if list_perm:  # among "permission" or "readPermission" or "writePermission", any of the permission is set
            for self_defined_permission in list_perm:  # (1)match any (2)ignore permission that is not found
                if self_defined_permission in PermissionName_to_ProtectionLevel:
                    protectionLevel = PermissionName_to_ProtectionLevel[self_defined_permission]
                    if (protectionLevel == 0) or (protectionLevel == 1):
                        is_dangerous = True
                        break
            if (exported == "") and (int_target_sdk >= 17) and (
            is_dangerous):  # permission is not set, it will depend on the Android system
                list_alerting_exposing_providers_no_exported_setting.append(i)

        else:  # none of any permission
            if exported.lower() == "true":
                is_dangerous = True
            elif (exported == "") and (
                int_target_sdk >= 17):  # permission is not set, it will depend on the Android system
                list_alerting_exposing_providers_no_exported_setting.append(i)

        if is_dangerous:
            list_alerting_exposing_providers.append(
                i)  # exported="true" and none of the permission are set => of course dangerous

    if list_alerting_exposing_providers or list_alerting_exposing_providers_no_exported_setting:
        if list_alerting_exposing_providers_no_exported_setting:  # providers that Did not set exported

            writer.startWriter("PERMISSION_PROVIDER_IMPLICIT_EXPORTED", LEVEL_CRITICAL,
                               "AndroidManifest ContentProvider 导出检查",
                               """我们强烈建议您明确指定 "exported" 属性(AndroidManifest.xml)。 
               对于 "android:targetSdkVersion" < 17, 默认情况下 ContentProvider 的导出值为 "true"。
               对于 "android:targetSdkVersion" >= 17, 默认情况下 ContentProvider 的导出值为 "false"。
               这意味着如果没有明确设置 "android:exported"，您要将您的 ContentProvider 公开到 Android < 4.2 的设备。
               即使您使用 [protectionalLevel="normal"] 设置提供程序的权限，由于默认约束，其他应用仍然无法访问 Android >= 4.2 的设备。
               如果您最初希望其他应用使用它（包括受 "Signature" 保护级别保护），请确保设置导出为 "true"，如果不想，则设置为 "false"。 
               如果您已将相应的 "permission"，"writePermission" 或 "readPermission" 设置为 "Signature" 保护级别或更高级别，请将 "exported" 指定为 "true"
               因为在 Android >= 4.2 的设备中由相同签名签名的其他应用无法访问它。
               参考： http://developer.android.com/guide/topics/manifest/provider-element.html#exported
               ContentProvider 漏洞案例： 
                 (1)https://www.nowsecure.com/mobile-security/ebay-android-content-provider-injection-vulnerability.html
                 (2)http://blog.trustlook.com/2013/10/23/ebay-android-content-provider-information-disclosure-vulnerability/
                 (3)http://www.wooyun.org/bugs/wooyun-2010-039169
               """)

            for i in list_alerting_exposing_providers_no_exported_setting:
                writer.write(("%10s => %s") % ("provider", i[0]))

        if list_alerting_exposing_providers:  # provider with "true" exported and not enough permission protected on it

            writer.startWriter("PERMISSION_PROVIDER_EXPLICIT_EXPORTED", LEVEL_CRITICAL,
                               "AndroidManifest ContentProvider 导出检查",
                               """找到 "exported" ContentProvider，允许设备上的任何其他应用程序访问它(AndroidManifest.xml)。
                               如果不想的话您应该将属性修改为 [exports = "false"]，或者至少设置 "signature" 保护权限。
               ContentProvider 漏洞案例： 
                 (1)https://www.nowsecure.com/mobile-security/ebay-android-content-provider-injection-vulnerability.html
                 (2)http://blog.trustlook.com/2013/10/23/ebay-android-content-provider-information-disclosure-vulnerability/
                 (3)http://www.wooyun.org/bugs/wooyun-2010-039169""")
            for i in list_alerting_exposing_providers:
                writer.write(("%10s => %s") % ("provider", i[0]))

    else:
        writer.startWriter("PERMISSION_PROVIDER_IMPLICIT_EXPORTED", LEVEL_INFO,
                           "AndroidManifest ContentProvider 导出检查",
                           "没有找到导出的 \"ContentProvider\"(AndroidManifest.xml)")

    # ------------------------------------------------------------------------
    # intent-filter checking:

    """
        Example misconfiguration:
            <receiver android:name=".service.push.SystemBroadcastReceiver">
                <intent-filter android:enabled="true" android:exported="false">
                    <action android:name="android.intent.action.BOOT_COMPLETED" />
                    <action android:name="android.intent.action.USER_PRESENT" />
                </intent-filter>
                <intent-filter android:enabled="true" android:exported="false">
                </intent-filter>
            </receiver>

        Detected1: <intent-filter android:enabled="true" android:exported="false">
        Detected2: No actions in "intent-filter"
    """

    find_tags = ["activity", "activity-alias", "service", "receiver"]
    xml = a.get_AndroidManifest()
    list_wrong_intent_filter_settings = []
    list_no_actions_in_intent_filter = []
    for tag in find_tags:
        for sitem in xml.getElementsByTagName(tag):
            isDetected1 = False
            isDetected2 = False
            for ssitem in sitem.getElementsByTagName("intent-filter"):
                if (ssitem.getAttribute("android:enabled") != "") or (ssitem.getAttribute("android:exported") != ""):
                    isDetected1 = True
                if len(sitem.getElementsByTagName("action")) == 0:
                    isDetected2 = True
            if isDetected1:
                list_wrong_intent_filter_settings.append((tag, sitem.getAttribute("android:name")))
            if isDetected2:
                list_no_actions_in_intent_filter.append((tag, sitem.getAttribute("android:name")))

    if list_wrong_intent_filter_settings or list_no_actions_in_intent_filter:
        if list_wrong_intent_filter_settings:
            writer.startWriter("PERMISSION_INTENT_FILTER_MISCONFIG", LEVEL_WARNING,
                               "AndroidManifest \"intent-filter\" 设置检查",
                               """这些组件的 "intent-filter" 配置错误(AndroidManifest.xml)。 
               "intent-filter" 不应该有 "android:exported" 或 "android:enabled" 属性。
               参考： http://developer.android.com/guide/topics/manifest/intent-filter-element.html
               """)
            for tag, name in list_wrong_intent_filter_settings:
                writer.write(("%10s => %s") % (tag, a.format_value(name)))

        if list_no_actions_in_intent_filter:
            writer.startWriter("PERMISSION_INTENT_FILTER_MISCONFIG", LEVEL_CRITICAL,
                               "AndroidManifest \"intent-filter\" 设置检查",
                               """这些组件的 "intent-filter" 配置错误(AndroidManifest.xml)。
               "intent-filter" 应该至少有一个 "action"。
               参考： http://developer.android.com/guide/topics/manifest/intent-filter-element.html
               """)
            for tag, name in list_no_actions_in_intent_filter:
                writer.write(("%10s => %s") % (tag, a.format_value(name)))
    else:
        writer.startWriter("PERMISSION_INTENT_FILTER_MISCONFIG", LEVEL_INFO,
                           "AndroidManifest \"intent-filter\" 设置检查",
                           "AndroidManifest \"intent-filter\" 检查正确。")

    # ------------------------------------------------------------------------
    # Implicit Service (** Depend on: "exported" checking (activity, activity-alias, service, receiver) **)

    if list_implicit_service_components:
        writer.startWriter("PERMISSION_IMPLICIT_SERVICE", LEVEL_CRITICAL, "隐性服务检查",
                           """ 为了确保您的应用程序安全，始终在启动服务时使用明确的 intent，不要为您的服务声明 intent filter。使用隐含的 intent 启动服务是一个安全隐患，因为您无法确定什么服务将响应 intent，并且用户无法查看哪个服务启动。
               参考： http://developer.android.com/guide/components/intents-filters.html#Types""",
                           ["Implicit_Intent"])

        for name in list_implicit_service_components:
            writer.write(("=> %s") % (a.format_value(name)))

    else:
        writer.startWriter("PERMISSION_IMPLICIT_SERVICE", LEVEL_INFO, "隐性服务检查",
                           "没有危险的隐性服务。", ["Implicit_Intent"])

    # ------------------------------------------------------------------------
    # SQLite databases

    is_using_android_dbs = vmx.get_tainted_packages().has_android_databases(filteringEngine.get_filtering_regexp())
    if is_using_android_dbs:
        if int_min_sdk < 15:
            writer.startWriter("DB_SQLITE_JOURNAL", LEVEL_NOTICE, "Android SQLite数据库漏洞检查",
                               """此应用使用 Android SQLite 数据库。 
               在 Android 4.0 之前，Android 有 SQLite Journal 信息泄露漏洞。
               但只能通过升级到 Android > 4.0 的用户解决问题，您无法通过自己的方式解决问题(但是可以使用 "SQLCipher" 或其他 libs 加密您的数据库和日记帐。
               POC 参考：
               (1) http://blog.watchfire.com/files/androidsqlitejournal.pdf 
               (2) http://www.youtube.com/watch?v=oCXLHjmH5rY """, ["Database"], "CVE-2011-3901")
        else:
            writer.startWriter("DB_SQLITE_JOURNAL", LEVEL_NOTICE, "Android SQLite数据库漏洞检查",
                               "这个应用程序正在使用 Android SQLite 数据库，但没有 SQLite Journal 信息泄露漏洞。",
                               ["Database"], "CVE-2011-3901")
    else:
        writer.startWriter("DB_SQLITE_JOURNAL", LEVEL_INFO, "Android SQLite数据库漏洞检查",
                           "这个应用程序没有使用 Android SQLite 数据库。", ["Database"], "CVE-2011-3901")

    # ------------------------------------------------------------------------
    # Checking whether the app is using SQLCipher:
    # Reference to <<Essential_Block_1>>
    if isUsingSQLCipher:
        writer.startWriter("DB_SQLCIPHER", LEVEL_NOTICE, "Android SQLite数据库加密（SQLCipher）",
                           "这个应用程序使用 SQLCipher 加密和解密数据库。(http://sqlcipher.net/)", ["Database"])

        path_sqlcipher_dbs = vmx.get_tainted_packages().search_sqlcipher_databases()  # Don't do the exclusion checking on this one because it's not needed

        if path_sqlcipher_dbs:
            # Get versions:
            has_version1or0 = False
            has_version2 = False
            for _, version in path_sqlcipher_dbs:
                if version == 1:
                    has_version1or0 = True
                if version == 2:
                    has_version2 = True

            if has_version1or0:
                writer.write(
                    "It's using \"SQLCipher for Android\" (Library version: 1.X or 0.X), package name: \"info.guardianproject.database\"")
            if has_version2:
                writer.write(
                    "It's using \"SQLCipher for Android\" (Library version: 2.X or higher), package name: \"net.sqlcipher.database\"")

            # Dumping:
            for db_path, version in path_sqlcipher_dbs:
                writer.show_Path(d, db_path)

    else:
        writer.startWriter("DB_SQLCIPHER", LEVEL_INFO, "Android SQLite数据库加密（SQLCipher）",
                           "这个应用程序没有使用 SQLCipher 加密和解密数据库。(http://sqlcipher.net/)", ["Database"])

    # ------------------------------------------------------------------------
    # Find "SQLite Encryption Extension (SEE) on Android"
    has_SSE_databases = False
    for cls in d.get_classes():
        if cls.get_name() == "Lorg/sqlite/database/sqlite/SQLiteDatabase;":  # Don't do the exclusion checking on this one because it's not needed
            has_SSE_databases = True
            break

    if has_SSE_databases:
        writer.startWriter("DB_SEE", LEVEL_NOTICE,
                           "Android SQLite数据库加密（SQLite加密扩展（SEE））",
                           "此应用程序在 Android 上使用 SQLite 加密扩展（SEE）来加密或解密数据库。(http://www.sqlite.org/android)",
                           ["Database"])

    else:
        writer.startWriter("DB_SEE", LEVEL_INFO,
                           "Android SQLite数据库加密（SQLite加密扩展（SEE））",
                           "此应用程序没有在 Android 上使用 SQLite 加密扩展（SEE）来加密或解密数据库。(http://www.sqlite.org/android)",
                           ["Database"])

    # ------------------------------------------------------------------------
    # Searching SQLite "PRAGMA key" encryption:
    result_sqlite_encryption = efficientStringSearchEngine.get_search_result_by_match_id("$__sqlite_encryption__")
    result_sqlite_encryption = filteringEngine.filter_efficient_search_result_value(result_sqlite_encryption)
    if result_sqlite_encryption:
        writer.startWriter("HACKER_DB_KEY", LEVEL_NOTICE, "Android SQLite 数据库加密的密钥",
                           "检测到使用对称密钥（PRAGMA密钥）加密 SQLite 数据库。 \n相关代码：",
                           ["Database", "Hacker"])

        for found_string, method in result_sqlite_encryption:
            writer.write(method.get_class_name() + "->" + method.get_name() + method.get_descriptor())
    else:
        writer.startWriter("HACKER_DB_KEY", LEVEL_INFO, "Android SQLite 数据库加密的 Key",
                           "没有检测到使用对称密钥（PRAGMA密钥）加密 SQLite 数据库。",
                           ["Database", "Hacker"])

    # ------------------------------------------------------------------------
    # Searching checking root or not:
    result_possibly_check_root = efficientStringSearchEngine.get_search_result_by_match_id("$__possibly_check_root__")
    result_possibly_check_su = efficientStringSearchEngine.get_search_result_by_match_id("$__possibly_check_su__")
    result_possibly_root_total = []

    if result_possibly_check_root:
        result_possibly_root_total.extend(result_possibly_check_root)

    if result_possibly_check_su:
        result_possibly_root_total.extend(result_possibly_check_su)

    result_possibly_root_total = filteringEngine.filter_efficient_search_result_value(result_possibly_root_total)

    if result_possibly_root_total:
        writer.startWriter("COMMAND_MAYBE_SYSTEM", LEVEL_NOTICE, "执行 \"root\" 或系统权限检查",
                           "应用程序可能有代码检查 \"root\" 权限，安装文件系统操作或监视系统：",
                           ["Command"])

        list_possible_root = []
        list_possible_remount_fs = []
        list_possible_normal = []

        for found_string, method in set(result_possibly_root_total):  # strip the duplicated items
            if ("'su'" == found_string) or ("/su" in found_string):
                list_possible_root.append((found_string, method, True))  # 3rd parameter: show string or not
            elif "mount" in found_string:  # mount, remount
                list_possible_remount_fs.append((found_string, method, True))
            else:
                list_possible_normal.append((found_string, method, True))

        lst_ordered_finding = []
        lst_ordered_finding.extend(list_possible_root)
        lst_ordered_finding.extend(list_possible_remount_fs)
        lst_ordered_finding.extend(list_possible_normal)

        for found_string, method, show_string in lst_ordered_finding:
            if show_string:
                writer.write(
                    method.get_class_name() + "->" + method.get_name() + method.get_descriptor() + "  => " + found_string)
            else:
                writer.write(method.get_class_name() + "->" + method.get_name() + method.get_descriptor())
    else:

        writer.startWriter("COMMAND_MAYBE_SYSTEM", LEVEL_INFO, "执行 \"root\" 或系统权限检查",
                           "没有找到检查 \"root\" 权限（su）或获得系统许可的代码。",
                           ["Command"])

    # ------------------------------------------------------------------------
    # Android getting IMEI, Android_ID, UUID problem

    path_Device_id = vmx.get_tainted_packages().search_class_methods_exact_match("Landroid/telephony/TelephonyManager;",
                                                                                 "getDeviceId", "()Ljava/lang/String;")
    path_Device_id = filteringEngine.filter_list_of_paths(d, path_Device_id)

    if path_Device_id:

        writer.startWriter("SENSITIVE_DEVICE_ID", LEVEL_WARNING, "获取 IMEI 和设备 ID",
                           """此应用程序的代码获取 "device id(IMEI)" ，但是方法 "TelephonyManager.getDeviceId()" 存在问题。
               1.Non-phones: 没有Wifi的设备或没有电话硬件的音乐播放器没有这种唯一标识符。
               2.Persistence: 在具有此功能的设备上，它会持续跨设备数据擦除并出厂设置。 在这种情况下，您的应用程序应该将其视为相同的设备，这一点并不清楚。
               3.Privilege: 它需要 READ_PHONE_STATE 权限，如果您不另外使用或需要电话，这是令人烦恼的。
               4.Bugs: 我们已经看到一些生产手机的实例，其实施是错误的并返回错误信息，例如零或星号。
               如果要获取设备的唯一 ID，我们建议您在以下文章中使用 "Installation" 框架。
               参考： http://android-developers.blogspot.tw/2011/03/identifying-app-installations.html
               """, ["Sensitive_Information"])

        writer.show_Paths(d, path_Device_id)

    else:

        writer.startWriter("SENSITIVE_DEVICE_ID", LEVEL_INFO, "获取 IMEI 和设备 ID",
                           "没有检测到这个应用程序正在通过 \"TelephonyManager.getDeviceId()\" 方法获取 \"device id(IMEI)\"。",
                           ["Sensitive_Information"])

    # ------------------------------------------------------------------------
    # Android "android_id"

    path_android_id = vmx.get_tainted_packages().search_class_methods_exact_match("Landroid/provider/Settings$Secure;",
                                                                                  "getString",
                                                                                  "(Landroid/content/ContentResolver; Ljava/lang/String;)Ljava/lang/String;")
    path_android_id = filteringEngine.filter_list_of_paths(d, path_android_id)

    list_android_id = []
    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d, path_android_id):
        if i.getResult()[1] is None:
            continue
        if i.getResult()[1] == "android_id":
            list_android_id.append(i.getPath())

    if list_android_id:
        writer.startWriter("SENSITIVE_SECURE_ANDROID_ID", LEVEL_WARNING, "获取 ANDROID_ID",
                           """This app has code getting the 64-bit number "Settings.Secure.ANDROID_ID". 
               ANDROID_ID seems a good choice for a unique device identifier. There are downsides: First, it is not 100% reliable on releases of Android prior to 2.2 (Froyo). 
               Also, there has been at least one widely-observed bug in a popular handset from a major manufacturer, where every instance has the same ANDROID_ID. 
               If you want to get an unique id for the device, we suggest you use "Installation" framework in the following article. 
               Please check the reference: http://android-developers.blogspot.tw/2011/03/identifying-app-installations.html 
               """, ["Sensitive_Information"])

        for path in list_android_id:
            writer.show_Path(d, path)
    else:

        writer.startWriter("SENSITIVE_SECURE_ANDROID_ID", LEVEL_INFO, "获取 ANDROID_ID",
                           "没有检测到这个应用程序正在获得64位数字 \"Settings.Secure.ANDROID_ID\"。",
                           ["Sensitive_Information"])

    # ------------------------------------------------------------------------
    # Checking sending SMS code

    """
      Example:
        Landroid/telephony/SmsManager;->sendDataMessage(Ljava/lang/String; Ljava/lang/String; S [B Landroid/app/PendingIntent; Landroid/app/PendingIntent;)V
        Landroid/telephony/SmsManager;->sendMultipartTextMessage(Ljava/lang/String; Ljava/lang/String; Ljava/util/ArrayList; Ljava/util/ArrayList; Ljava/util/ArrayList;)V
        Landroid/telephony/SmsManager;->sendTextMessage(Ljava/lang/String; Ljava/lang/String; Ljava/lang/String; Landroid/app/PendingIntent; Landroid/app/PendingIntent;)V
    """

    list_sms_signatures = [
        ("sendDataMessage",
         "(Ljava/lang/String; Ljava/lang/String; S [B Landroid/app/PendingIntent; Landroid/app/PendingIntent;)V"),
        ("sendMultipartTextMessage",
         "(Ljava/lang/String; Ljava/lang/String; Ljava/util/ArrayList; Ljava/util/ArrayList; Ljava/util/ArrayList;)V"),
        ("sendTextMessage",
         "(Ljava/lang/String; Ljava/lang/String; Ljava/lang/String; Landroid/app/PendingIntent; Landroid/app/PendingIntent;)V")
    ]

    path_sms_sending = vmx.get_tainted_packages().search_class_methodlist_exact_match("Landroid/telephony/SmsManager;",
                                                                                      list_sms_signatures)
    path_sms_sending = filteringEngine.filter_list_of_paths(d, path_sms_sending)

    if path_sms_sending:
        writer.startWriter("SENSITIVE_SMS", LEVEL_WARNING, "发送短信的代码",
                           "此应用程序具有发送短信的代码（sendDataMessage，sendMultipartTextMessage或sendTextMessage）：")
        writer.show_Paths(d, path_sms_sending)
    else:
        writer.startWriter("SENSITIVE_SMS", LEVEL_INFO, "发送短信的代码",
                           "没有检测到此应用程序具有发送短信的代码（sendDataMessage，sendMultipartTextMessage或sendTextMessage）。")

    # ------------------------------------------------------------------------
    # Checking shared_user_id

    sharedUserId = a.get_shared_user_id()
    sharedUserId_in_system = False

    if (sharedUserId == "android.uid.system"):
        sharedUserId_in_system = True

    if sharedUserId_in_system:
        writer.startWriter("SHARED_USER_ID", LEVEL_NOTICE, "AndroidManifest sharedUserId 检查",
                           "这个程序使用 \"android.uid.system\" 共享用户ID, 这需要 \"system(uid = 1000)\" 权限。必须使用制造商的密钥库或Google的密钥库来签名，才能成功安装在用户的设备上。",
                           ["System"])
    else:
        writer.startWriter("SHARED_USER_ID", LEVEL_INFO, "AndroidManifest sharedUserId 检查",
                           "这个程序没有使用 \"android.uid.system\" 共享用户ID。", ["System"])

    # System shared_user_id + Master Key Vulnerability checking: (Depends on "Master Key Vulnerability checking")
    if sharedUserId_in_system and isMasterKeyVulnerability:
        writer.startWriter("MASTER_KEY_SYSTEM_APP", LEVEL_CRITICAL, "具有主密钥漏洞的系统root",
                           "该应用程序是一个恶意软件，它使用主密钥漏洞的 \"system(uid=1000)\" 特权, 导致设备被 root。")

    # ------------------------------------------------------------------------
    # File delete alert

    path_FileDelete = vmx.get_tainted_packages().search_class_methods_exact_match("Ljava/io/File;", "delete", "()Z")
    path_FileDelete = filteringEngine.filter_list_of_paths(d, path_FileDelete)

    if path_FileDelete:
        writer.startWriter("FILE_DELETE", LEVEL_NOTICE, "文件不安全删除检查",
                           """您删除的所有内容可能由任何用户或攻击者恢复。（尤其是已root的设备）
               请确保没有使用 "file.delete()" 删除关键文件。
               参考：https://www.youtube.com/watch?v=tGw1fxUD-uY""")
        writer.show_Paths(d, path_FileDelete)
    else:
        writer.startWriter("FILE_DELETE", LEVEL_INFO, "文件不安全删除检查",
                           "没有检测到不安全删除文件。")

    # ------------------------------------------------------------------------
    # Check if app check for installing from Google Play

    path_getInstallerPackageName = vmx.get_tainted_packages().search_class_methods_exact_match(
        "Landroid/content/pm/PackageManager;", "getInstallerPackageName", "(Ljava/lang/String;)Ljava/lang/String;")
    path_getInstallerPackageName = filteringEngine.filter_list_of_paths(d, path_getInstallerPackageName)

    if path_getInstallerPackageName:
        writer.startWriter("HACKER_INSTALL_SOURCE_CHECK", LEVEL_NOTICE, "APK安装源检查",
                           "此应用程式有 APK 安装程式来源（例如Google Play，亚马逊等）的代码检查。它可能用于检查应用程序是否被攻击者入侵。",
                           ["Hacker"])
        writer.show_Paths(d, path_getInstallerPackageName)
    else:
        writer.startWriter("HACKER_INSTALL_SOURCE_CHECK", LEVEL_INFO, "APK安装源检查",
                           "没有检测到这个应用程序检查APK安装程序源。", ["Hacker"])

    # ------------------------------------------------------------------------
    # WebView setAllowFileAccess:

    """
        Get all "dst" class: Landroid/webkit/WebSettings;
          => Categorized by src function,
             If the src function:
               1.setAllowFileAccess does not exist    OR
               2.setAllowFileAccess(true)
                   =>src function may be vulnerable

        **Why check WebSettings? It's because WebView almost always uses the method: WebView->getSettings()

        **Even if the below example, it will finally call WebSettings:
          class TestWebView extends WebView {
            public TestWebView(Context context) {
              super(context);
            }
          }
    """

    pkg_WebView_WebSettings = vmx.get_tainted_packages().search_packages("Landroid/webkit/WebSettings;")
    pkg_WebView_WebSettings = filteringEngine.filter_list_of_paths(d, pkg_WebView_WebSettings)

    dict_WebSettings_ClassMethod_to_Path = {}

    for path in pkg_WebView_WebSettings:
        src_class_name, src_method_name, src_descriptor = path.get_src(cm)
        dst_class_name, dst_method_name, dst_descriptor = path.get_dst(cm)

        dict_name = src_class_name + "->" + src_method_name + src_descriptor
        if dict_name not in dict_WebSettings_ClassMethod_to_Path:
            dict_WebSettings_ClassMethod_to_Path[dict_name] = []

        dict_WebSettings_ClassMethod_to_Path[dict_name].append((dst_method_name + dst_descriptor, path))

    path_setAllowFileAccess_vulnerable_ready_to_test = []
    path_setAllowFileAccess_confirm_vulnerable_src_class_func = []

    for class_fun_descriptor, value in dict_WebSettings_ClassMethod_to_Path.items():
        has_Settings = False
        for func_name_descriptor, path in value:
            if func_name_descriptor == "setAllowFileAccess(Z)V":
                has_Settings = True

                # Add ready-to-test Path list
                path_setAllowFileAccess_vulnerable_ready_to_test.append(path)
                break

        if not has_Settings:
            # Add vulnerable Path list
            path_setAllowFileAccess_confirm_vulnerable_src_class_func.append(class_fun_descriptor)

    for i in analysis.trace_Register_value_by_Param_in_source_Paths(d,
                                                                    path_setAllowFileAccess_vulnerable_ready_to_test):
        if (i.getResult()[1] == 0x1):  # setAllowFileAccess is true

            path = i.getPath()
            src_class_name, src_method_name, src_descriptor = path.get_src(cm)
            dict_name = src_class_name + "->" + src_method_name + src_descriptor

            if dict_name not in path_setAllowFileAccess_confirm_vulnerable_src_class_func:
                path_setAllowFileAccess_confirm_vulnerable_src_class_func.append(dict_name)

    if path_setAllowFileAccess_confirm_vulnerable_src_class_func:

        path_setAllowFileAccess_confirm_vulnerable_src_class_func = sorted(
            set(path_setAllowFileAccess_confirm_vulnerable_src_class_func))

        writer.startWriter("WEBVIEW_ALLOW_FILE_ACCESS", LEVEL_WARNING, "WebView本地文件访问攻击检查",
                           """Found "setAllowFileAccess(true)" or not set(enabled by default) in WebView. The attackers could inject malicious script into WebView and exploit the opportunity to access local resources. This can be mitigated or prevented by disabling local file system access. (It is enabled by default)
               Note that this enables or disables file system access only. Assets and resources are still accessible using file:///android_asset and file:///android_res.
               The attackers can use "mWebView.loadUrl("file:///data/data/[Your_Package_Name]/[File]");" to access app's local file.
               Reference: (1)https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/
                          (2)http://developer.android.com/reference/android/webkit/WebSettings.html#setAllowFileAccess(boolean)
               Please add or modify "yourWebView.getSettings().setAllowFileAccess(false)" to your WebView:
               """, ["WebView"])
        for i in path_setAllowFileAccess_confirm_vulnerable_src_class_func:
            writer.write(i)

    else:
        writer.startWriter("WEBVIEW_ALLOW_FILE_ACCESS", LEVEL_INFO, "WebView本地文件访问攻击检查",
                           "没有找到潜在的本地文件访问设置。", ["WebView"])

    # ------------------------------------------------------------------------
    # Adb Backup check

    if a.is_adb_backup_enabled():
        writer.startWriter("ALLOW_BACKUP", LEVEL_NOTICE, "AndroidManifest Adb备份检查",
                           """这个应用程式的ADB备份已启用（预设：ENABLED）。泄露敏感数据，包括终身访问令牌密码等。
               相关案例：
               1.http://www.securityfocus.com/archive/1/530288/30/0/threaded
               2.http://blog.c22.cc/advisories/cve-2013-5112-evernote-android-insecure-storage-of-pin-data-bypass-of-pin-protection/
               3.http://nelenkov.blogspot.co.uk/2012/06/unpacking-android-backups.html
               Reference: http://developer.android.com/guide/topics/manifest/application-element.html#allowbackup
               """)
    else:
        writer.startWriter("ALLOW_BACKUP", LEVEL_INFO, "AndroidManifest Adb备份检查",
                           "此应用已禁用 Adb 备份。")

    # ------------------------------------------------------------------------
    # SSL Verification Fail (To check whether the code verifies the certificate)

    methods_X509TrustManager_list = get_method_ins_by_implement_interface_and_method_desc_dict(d, [
        "Ljavax/net/ssl/X509TrustManager;"],["getAcceptedIssuers()[Ljava/security/cert/X509Certificate;",
                                             "checkClientTrusted([Ljava/security/cert/X509Certificate; Ljava/lang/String;)V",
                                             "checkServerTrusted([Ljava/security/cert/X509Certificate; Ljava/lang/String;)V"])

    list_X509Certificate_Critical_class = []
    list_X509Certificate_Warning_class = []

    for class_name, method_list in methods_X509TrustManager_list.items():
        ins_count = 0

        for method in method_list:
            for ins in method.get_instructions():
                ins_count = ins_count + 1

        if ins_count <= 4:
            # Critical
            list_X509Certificate_Critical_class.append(class_name)
        else:
            # Warning
            list_X509Certificate_Warning_class.append(class_name)

    if list_X509Certificate_Critical_class or list_X509Certificate_Warning_class:

        log_level = LEVEL_WARNING
        log_partial_prefix_msg = "Please make sure this app has the conditions to check the validation of SSL Certificate. If it's not properly checked, it MAY allows self-signed, expired or mismatch CN certificates for SSL connection."

        if list_X509Certificate_Critical_class:
            log_level = LEVEL_CRITICAL
            log_partial_prefix_msg = "This app DOES NOT check the validation of SSL Certificate. It allows self-signed, expired or mismatch CN certificates for SSL connection."

        list_X509Certificate_merge_list = []
        list_X509Certificate_merge_list.extend(list_X509Certificate_Critical_class)
        list_X509Certificate_merge_list.extend(list_X509Certificate_Warning_class)

        dict_X509Certificate_class_name_to_caller_mapping = {}

        for method in d.get_methods():
            for i in method.get_instructions():  # method.get_instructions(): Instruction
                if i.get_op_value() == 0x22:  # 0x22 = "new-instance"
                    if i.get_string() in list_X509Certificate_merge_list:
                        referenced_class_name = i.get_string()
                        if referenced_class_name not in dict_X509Certificate_class_name_to_caller_mapping:
                            dict_X509Certificate_class_name_to_caller_mapping[referenced_class_name] = []

                        dict_X509Certificate_class_name_to_caller_mapping[referenced_class_name].append(method)

        writer.startWriter("SSL_X509", log_level, "SSL证书验证检查",
                           log_partial_prefix_msg + """
这是一个关键的漏洞，并允许攻击者在您不知情的情况下进行 MITM 攻击。
如果您传输用户的用户名或密码，这些敏感信息可能会泄漏。
参考：
(1)OWASP Mobile Top 10: https://www.owasp.org/index.php/Mobile_Top_10_2014-M3
(2)Android Security book: http://goo.gl/BFb65r 
(3)https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=134807561
强烈建议您使用现有 API，而不是创建自己的 X509 Certificate 类。
请修改或删除这些易受攻击的代码：
""", ["SSL_Security"])
        if list_X509Certificate_Critical_class:
            writer.write("[Confirm Vulnerable]")
            for name in list_X509Certificate_Critical_class:
                writer.write("=> " + name)
                if name in dict_X509Certificate_class_name_to_caller_mapping:
                    for used_method in dict_X509Certificate_class_name_to_caller_mapping[name]:
                        writer.write(
                            "      -> used by: " + used_method.get_class_name() + "->" + used_method.get_name() + used_method.get_descriptor())

        if list_X509Certificate_Warning_class:
            writer.write("--------------------------------------------------")
            writer.write("[Maybe Vulnerable (Please manually confirm)]")
            for name in list_X509Certificate_Warning_class:
                writer.write("=> " + name)
                if name in dict_X509Certificate_class_name_to_caller_mapping:
                    for used_method in dict_X509Certificate_class_name_to_caller_mapping[name]:
                        writer.write(
                            "      -> used by: " + used_method.get_class_name() + "->" + used_method.get_name() + used_method.get_descriptor())

    else:
        writer.startWriter("SSL_X509", LEVEL_INFO, "SSL证书验证检查",
                           "没有找到易受攻击的 X509 证书代码。", ["SSL_Security"])

    # ----------------------------------------------------------------
    # Must complete the last writer

    writer.completeWriter()

    # ----------------------------------------------------------------
    # End of Checking


def save_in_file(writer, app_home):
    """
    将结果存入txt文件
    """
    return writer.save_result_to_file(app_home + "/vulnerability_report.txt")


def do_vulnerability_scan(app_home, path_to_apk):
    writer = Writer()

    try:
        print("开始漏洞扫描: %s" % path_to_apk)
        do_analyze(writer, app_home, path_to_apk)
        save_in_file(writer, app_home)
        print("漏洞扫描完成")
    except Exception as e:
        print(e)
        print("漏洞扫描失败")

do_vulnerability_scan("/home/firmy/Downloads/annhub/SaveAPKs/87d93d33e2ec5ae15b93fdaa642ffeb0","/home/firmy/Downloads/annhub/SaveAPKs/87d93d33e2ec5ae15b93fdaa642ffeb0/87d93d33e2ec5ae15b93fdaa642ffeb0.apk")
